### 70. 爬楼梯

* 一开始这道题说实话没想明白，知道是动规，因为明显是穷举所有可行解，那就是直接上拉神的动规框架，一个递归和一个迭代
* 然后就是状态转移方程是啥，这个其实就是跟斐波那契数列一样的，`f(n) = f(n - 1) + f(n - 2)`，我也真没想出来，转过来劲才明白，n = 1 那就是 1，n = 2 就是 2，n = 3 就是 3，n = 4 时候不行画一下就是 5，这样就差不多了，有纸有笔还是能帮上忙
* 这个时候暴力递归，带备忘录的，基础动规，状态压缩优化版的动规直接就咔咔上，但需要注意一个细节，就是在 base case 这里 n = 2 的时候爬楼梯和动态规划是不一样的
* 第一种：暴力递归，直接超时，所以这个要提交的话肯定不能这么写，我猜如果面试问这种大概率是要追问优化方法的

```js
var climbStairs = function (n) {
  const dp = (n) => {
    // base case
    if (n === 1) return 1;
    if (n === 2) return 2;
    return dp(n - 1) + dp(n - 2)
  }
  return dp(n)
}
```

* 第二种：带备忘录的递归
* 时间复杂度超过 81.80% 提交，空间复杂度超过 76.79% 提交，这个时间复杂度过得去，但我还是感觉面试官会接着追问动规版本的

```js
var climbStairs = function (n) {
  let memo = []
  const dp = (n) => {
    if (n === 1) return 1;
    if (n === 2) return 2;
    if (memo[n]) return memo[n]; // 已经计算过，不用再计算了
    memo[n] = dp(n - 1) + dp(n - 2)
    return memo[n]
  }
  return dp(n)
}
```

* 这里有个写法的区别，我感觉是个人习惯上的，把两种都对的列出来

```js
let memo = []
if (memo[n]) return memo[n];

// 另一种写法
let memo = new Array(n + 1).fill(0) // 备忘录全初始化为 0
if (memo[n] !== 0) return memo[n]
```

* 第三种：常规动规
* 时间复杂度超过 93.57% 提交，空间复杂度超过 90.64% 提交，感觉面试官有可能还会接着问都写到这了。。。。。

```js
var climbStairs = function (n) {
  let dp = new Array(n + 1).fill(0)
  // base case 不设置 dp[0] = 0 是因为 fill 默认值为 0 了
  dp[1] = 1
  dp[2] = 2
  for (let i = 3; i <= n; i++) {
    dp[i] = dp[i - 1] + dp[i - 2]
  }
  return dp[n]
}
```

* 第四种：状态压缩优化版动规
* 时间复杂度超过 98.45% 提交，空间复杂度超过 46.85% 提交

```js
var climbStairs = function (n) {
	// base case
  if (n === 1) return 1;
  if (n === 2) return 2;
  let prev = 1, cur = 2
  for (let i = 3; i <= n; i++) {
    let sum = prev + cur
    prev = cur
    cur = sum
  }
  return cur
}
```

