### 62. 不同路径

* 动规系列刷的第一题，两步走，拉神的动规框架和状态转移方程

```js
// 拉神的自底向上迭代的动态规划框架
// base case
dp[0][0]... = base case
// 进行状态转移
for (状态1 in 状态1的所有取值) {
  for (状态2 in 状态2的所有取值) {
    for (...) {
      dp[状态1][状态2][...] = 求最值(选择1，选择2...)
    }
  }
}

```

* 这道题的状态转移方程可以通过简单分析得出，要走到 `i,j` 点，要么从 `i-1,j` 向右，要么从 `i,j-1` 向下，由此可得路径转移方程 `f(i,j) = f(i-1,j) + f(i,j-1)`
* 第一种：自底向上的 dp 数组迭代递推解法，这里有几种小变种
* 迭代的第一个写法是我写的
* 时间复杂度超过 95.98% 提交，空间复杂度超过 58.50% 提交

```js
var uniquePaths = function(m, n) {
  // 这种写法直接创建后一个 m x n 的二维数组，并且把所有格子都填为 1
  // 这里的思路是二维数组的第一列和第一行都只能是 1，因为只能向下或向右移动
  const dp = new Array(m).fill(1).map(() => new Array(n).fill(1))
  // 根据状态转移方程，比如走到 [3, 3] 的路径数，就是 [2, 3] 和 [3, 2] 路径数的总和
  // 这里注意 i 和 j 都是从 1 开始，因为第一行和第一列也就是索引为 0 的都填过了
  for (let i = 1; i < m; i++) {
    for (let j = 1; j < n; j++) {
      dp[i][j] = dp[i - 1][j] + dp[i][j - 1]
    }
  }
  return dp[m - 1][n - 1] // 注意答案是 m - 1 和 n - 1，不是 m 和 n
}
```

* 用一个三行三列的举例，看起来比较直观

![62](../assets/62.png)

* 迭代的第二种写法来自双越老师，就是慕课网上前端教的特别好的那位，也是 wangEditor 的作者
* 时间复杂度超过 48.72% 提交，空间复杂度超过 42.85% 提交

```js
var uniquePaths = function(m, n) {
  // 分两次建立一个二维 m x n 数组
  const dp = new Array(m)
  for (let i = 0; i < m; i++) {
    dp[i] = new Array(n)
  }
  // 如果只走第一行，就只有一条路径，所以第一行所有 item 都填充 1
  dp[0].fill(1)
  // 如果只走第一列，也只有一条路径。所以第一列所有 item 都填充 1
  for (let i = 0; i < m; i++) {
    dp[i][0] = 1
  }
  // 这里开始和上面的就一样了
  for (let i = 1; i < m; i++) {
    for (let j = 1; j < n; j++) {
      dp[i][j] = dp[i - 1][j] + dp[i][j - 1]
    }
  }
  return dp[m - 1][n - 1]
}
```

* 迭代的第三种写法来自大安老师，这种我理解是把 base case 拿出来，感觉要更加规范，我的写法都没 base case 了
* 时间复杂度超过 70.54% 提交，空间复杂度超过 9.10% 提交

```js
var uniquePaths = function(m, n) {
	const dp = new Array(m).fill(0).map(() => new Array(n).fill(0))
  // 这里 i 和 j 都需要从 0 开始而不是 1 了
  for (let i = 0; i < m; i++) {
    for (let j = 0; j < n; j++) {
      if (i === 0 || j === 0) dp[i][j] = 1; // base case
      else dp[i][j] = dp[i - 1][j] + dp[i][j - 1]
    }
  }
  return dp[m - 1][n - 1]
}
```

* 第二种：自顶向下的备忘录递归解法，借鉴自大安老师
* 先上一个拉神的递归版动规框架

```js
// 拉神的自顶向下递归的动态规划框架
var dp = function(状态1, 状态2, ...) {
  for (选择 in 所有可能的选择) {
    // 此时的状态已经因为做了选择而改变
    result = 求最值(result, dp(状态1, 状态2, ...))
  }
  return result
}
```

* 时间复杂度超过 70.54% 提交，空间复杂度超过 67.06% 提交

```js
var uniquePaths = function(m, n) {
	let memo = new Array(m).fill(0).map(() => new Array(n).fill(0))
	const dp = (i, j) => {
    // 判断 i 和 j 是否等于小于 0 是因为 i 和 j 是递减的，思路得按递归的想了，我一上来这就没想通。。。
    if (i === 0 && j === 0) return 1;
    if (i < 0 || j < 0) return 0;
    if (memo[i][j] > 0) return memo[i][j];
    memo[i][j] = dp(i - 1, j) + dp(i, j - 1)
    return memo[i][j]
  }
  return dp(m - 1, n - 1)
};
```

### 70. 爬楼梯

* 一开始这道题说实话没想明白，知道是动规，因为明显是穷举所有可行解，那就是直接上拉神的动规框架，一个递归和一个迭代
* 然后就是状态转移方程是啥，这个其实就是跟斐波那契数列一样的，`f(n) = f(n - 1) + f(n - 2)`，我也真没想出来，转过来劲才明白，n = 1 那就是 1，n = 2 就是 2，n = 3 就是 3，n = 4 时候不行画一下就是 5，这样就差不多了，有纸有笔还是能帮上忙
* 这个时候暴力递归，带备忘录的，基础动规，状态压缩优化版的动规直接就咔咔上，但需要注意一个细节，就是在 base case 这里 n = 2 的时候爬楼梯和动态规划是不一样的
* 第一种：暴力递归，直接超时，所以这个要提交的话肯定不能这么写，我猜如果面试问这种大概率是要追问优化方法的

```js
var climbStairs = function (n) {
  const dp = (n) => {
    // base case
    if (n === 1) return 1;
    if (n === 2) return 2;
    return dp(n - 1) + dp(n - 2)
  }
  return dp(n)
}
```

* 第二种：带备忘录的递归
* 时间复杂度超过 81.80% 提交，空间复杂度超过 76.79% 提交，这个时间复杂度过得去，但我还是感觉面试官会接着追问动规版本的

```js
var climbStairs = function (n) {
  let memo = []
  const dp = (n) => {
    if (n === 1) return 1;
    if (n === 2) return 2;
    if (memo[n]) return memo[n]; // 已经计算过，不用再计算了
    memo[n] = dp(n - 1) + dp(n - 2)
    return memo[n]
  }
  return dp(n)
}
```

* 这里有个写法的区别，我感觉是个人习惯上的，把两种都对的列出来

```js
let memo = []
if (memo[n]) return memo[n];

// 另一种写法
let memo = new Array(n + 1).fill(0) // 备忘录全初始化为 0
if (memo[n] !== 0) return memo[n]
```

* 第三种：常规动规
* 时间复杂度超过 93.57% 提交，空间复杂度超过 90.64% 提交，感觉面试官有可能还会接着问都写到这了。。。。。

```js
var climbStairs = function (n) {
  let dp = new Array(n + 1).fill(0)
  // base case 不设置 dp[0] = 0 是因为 fill 默认值为 0 了
  dp[1] = 1
  dp[2] = 2
  for (let i = 3; i <= n; i++) {
    dp[i] = dp[i - 1] + dp[i - 2]
  }
  return dp[n]
}
```

* 第四种：状态压缩优化版动规
* 时间复杂度超过 98.45% 提交，空间复杂度超过 46.85% 提交

```js
var climbStairs = function (n) {
  let first = 1, second = 2
  // base case
  if (n === 1) return first;
  if (n === 2) return second;
  for (let i = 3; i <= n; i++) {
    let sum = first + second
    // 需要注意这两行的顺序不能反，否则就错了，得稍微想一想这里是吧
    first = second
    second = sum
  }
  return second
}
```

