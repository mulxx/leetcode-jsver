## 114. 二叉树展开为链表

第一种解法：分解问题

这个是[拉神的思路](https://labuladong.gitee.io/algo/2/21/37/)，我个人非常喜欢，如果让我面试写我就写这个，推荐给大家

<img src="../assets/22102702.jpeg" alt="22102702" style="zoom:50%;" />

对于一个节点 `x`，可以执行以下流程

* 1、先利用 `flatten(x.left)` 和 `flatten(x.right)` 将 `x` 的左右子树拉平
* 2、将 `x` 的右子树接到左子树下方，然后将整个左子树作为右子树

这样，以 `x` 为根的整棵二叉树就被拉平了，恰好完成了 `flatten(x)` 的定义，`flatten` 函数是怎么把左右子树拉平的不容易说清楚，但是只要知道 `flatten` 的定义如此并利用这个定义，让每一个节点做它该做的事情，然后 `flatten` 函数就会按照定义工作

时间复杂度超过 90.87% 提交，空间复杂度超过 59.01% 提交

```js
var flatten = function(root) {
  if (root == null) return null;
  // 利用定义，把左右子树拉平
  flatten(root.left)
  flatten(root.right)
  // 后序遍历位置
  // 1、左右子树已经被拉平成一条链表
  let left = root.left
  let right = root.right
  // 2、将左子树作为右子树
  root.left = null
  root.right = left
  // 3、将原先的右子树接到当前右子树的末端
  while (root.right != null) {
    root = root.right // 走到原左子树的末端
  }
  root.right = right // 将右子树接上去
  return root
}
```

第二种解法：前序遍历

这个解法的思路关键个人认为就是先对二叉树进行一遍前序遍历，遍历各节点的顺序就是单链表中的节点顺序，然后更新再在中间插入 null

时间复杂度超过 96.98% 提交，空间复杂度超过 31.13% 提交，但是这个不符合题目进阶要求在原地展开

```js
var flatten = function(root) {
  let res = []
  // 这个前序遍历代码几乎完全就是 #144 的答案
  const preOrderTraversal = (root, res) => {
    if (root == null) return res;
    res.push(root)
    preOrderTraversal(root.left, res)
    preOrderTraversal(root.right, res)
  }
  preOrderTraversal(root, res)
  for (let i = 1; i < res.length; i++) {
    let pre = res[i - 1]
    let cur = res[i]
    pre.left = null
    pre.right = cur
  }
  return res
}
```

## 116. 填充每个节点的下一个右侧节点指针

题目的意思就是把二叉树的每一层节点都用 `next` 指针连接起来，输入是一棵「完美二叉树」，形象地说整棵二叉树是一个正三角形，除了最右侧的节点 `next` 指针会指向 `null`，其他节点的右侧一定有相邻的节点

简单的把每个节点自己的 `next` 指针指向右侧节点的想法在这道题上是有问题的，因为它只能把相同父节点的两个节点穿起来

**传统的 `traverse` 函数是遍历二叉树的所有节点，但现在想遍历的其实是两个相邻节点之间的「空隙」**

第一种解法：遍历三叉树

借用[拉神的这个示意图](https://labuladong.gitee.io/algo/2/21/37/)一下，在二叉树的基础上进行抽象，把图中的每一个方框看做一个节点

<img src="../assets/22102701.png" alt="22102701" style="zoom: 50%;" />

这样，一棵二叉树被抽象成了一棵三叉树，三叉树上的每个节点就是原先二叉树的两个相邻节点

现在，只要实现一个 `traverse` 函数来遍历这棵三叉树，每个「三叉树节点」需要做的事就是把自己内部的两个二叉树节点穿起来

时间复杂度超过 55.30% 提交，空间复杂度超过 65.95% 提交

```js
var connect = function(root) {
  if (root == null) return root;
  // 三叉树遍历框架
  const traverse = (node1, node2) => {
    if (node1 == null || node2 == null) return;
    
    node1.next = node2 // 在前序位置将传入的两个节点串起来
    
    traverse(node1.left, node1.right)
    traverse(node1.right, node2.left) // 连接跨越父节点的两个子节点
    traverse(node2.left, node2.right)
  }
  traverse(root.left, root.right) // 遍历「三叉树」，连接相邻节点
  return root
}
```

第二种解法：DFS 的另一思路

这个思路是借鉴[安神](https://leetcode.cn/problems/populating-next-right-pointers-in-each-node/solution/tu-jie-liang-chong-bu-tong-de-di-gui-si-eyctg/)的，里面又套娃了另一个[题解](https://leetcode.cn/problems/populating-next-right-pointers-in-each-node/solution/shou-hua-tu-jie-dfs-di-gui-yi-yu-li-jie-by-xiao_be/)，讲的更细，一句话总结就是「只要判断当前节点是否有 next 指针，如果有的话，则当前节点的右子节点就指向它的 next 指针的左子节点」

时间复杂度超过 100.00% 提交，空间复杂度超过 97.05% 提交，非常奈斯

```js
var connect = function(root) {
  if (root == null || root.left == null) return root;
  
  
  root.left.next = root.right // 把左子节点的 next 指针指向右子节点
  // 和常规思路「把每个节点自己的 next 指针指向右侧节点」唯一区别就在于下面多加的这一行
  if (root.next) root.right.next = root.next.left
  
  connect(root.left)
  connect(root.right)
  return root
}
```

第三种解法：BFS

这个也是借鉴[安神](https://leetcode.cn/problems/populating-next-right-pointers-in-each-node/solution/tu-jie-liang-chong-bu-tong-de-di-gui-si-eyctg/)的，在广度的遍历里就顺便把 next 指针弄好了，非常简洁（待填坑）