## 114. 二叉树展开为链表



## 116. 填充每个节点的下一个右侧节点指针

题目的意思就是把二叉树的每一层节点都用 `next` 指针连接起来，输入是一棵「完美二叉树」，形象地说整棵二叉树是一个正三角形，除了最右侧的节点 `next` 指针会指向 `null`，其他节点的右侧一定有相邻的节点

简单的把每个节点自己的 `next` 指针指向右侧节点的想法在这道题上是有问题的，因为它只能把相同父节点的两个节点穿起来

**传统的 `traverse` 函数是遍历二叉树的所有节点，但现在想遍历的其实是两个相邻节点之间的「空隙」**

第一种解法：遍历三叉树

借用[拉神的这个示意图](https://labuladong.gitee.io/algo/2/21/37/)一下，在二叉树的基础上进行抽象，把图中的每一个方框看做一个节点

<img src="../assets/22102701.png" alt="22102701" style="zoom: 50%;" />

这样，一棵二叉树被抽象成了一棵三叉树，三叉树上的每个节点就是原先二叉树的两个相邻节点

现在，只要实现一个 `traverse` 函数来遍历这棵三叉树，每个「三叉树节点」需要做的事就是把自己内部的两个二叉树节点穿起来

时间复杂度超过 55.30% 提交，空间复杂度超过 65.95% 提交

```js
var connect = function(root) {
  if (root == null) return root;
  // 三叉树遍历框架
  const traverse = (node1, node2) => {
    if (node1 == null || node2 == null) return;
    
    node1.next = node2 // 在前序位置将传入的两个节点串起来
    
    traverse(node1.left, node1.right)
    traverse(node1.right, node2.left) // 连接跨越父节点的两个子节点
    traverse(node2.left, node2.right)
  }
  traverse(root.left, root.right) // 遍历「三叉树」，连接相邻节点
  return root
}
```

第二种解法：DFS 的另一思路

这个思路是借鉴[安神](https://leetcode.cn/problems/populating-next-right-pointers-in-each-node/solution/tu-jie-liang-chong-bu-tong-de-di-gui-si-eyctg/)的，里面又套娃了另一个[题解](https://leetcode.cn/problems/populating-next-right-pointers-in-each-node/solution/shou-hua-tu-jie-dfs-di-gui-yi-yu-li-jie-by-xiao_be/)，讲的更细，一句话总结就是「只要判断当前节点是否有 next 指针，如果有的话，则当前节点的右子节点就指向它的 next 指针的左子节点」

时间复杂度超过 100.00% 提交，空间复杂度超过 97.05% 提交，非常奈斯

```js
var connect = function(root) {
  if (root == null || root.left == null) return root;
  
  
  root.left.next = root.right // 把左子节点的 next 指针指向右子节点
  // 和常规思路「把每个节点自己的 next 指针指向右侧节点」唯一区别就在于下面多加的这一行
  if (root.next) root.right.next = root.next.left
  
  connect(root.left)
  connect(root.right)
  return root
}
```

第三种解法：BFS

这个也是借鉴[安神](https://leetcode.cn/problems/populating-next-right-pointers-in-each-node/solution/tu-jie-liang-chong-bu-tong-de-di-gui-si-eyctg/)的，在广度的遍历里就顺便把 next 指针弄好了，非常简洁（待填坑）