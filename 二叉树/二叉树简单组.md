## 94. 二叉树的中序遍历

* 第一种解法：递归
* 这种就是拉神的二叉树遍历框架，直接套就完事，前提得看过拉神讲解哦，我信心满满地咔咔写上去，结果直接解答错误，只通过了 2 个测试用例，当时我就懵了

```js
// 错误版本
var inorderTraversal = function(root) {
  let res = []
  if (root == null) return res;
  inorderTraversal(root.left)
  res.push(root.val)
  inorderTraversal(root.right)
  return res
}
```

* 然后我就去看题解，发现我的跟正确的相比在形参这里就有区别，正确的是要把返回的数组当作形参传进去，但默认的模板一开始只有一个形参，我也没遇见过还可以改函数默认定义的，然后就学到了，哦原来是可以动默认函数定义的
* 递归的时间复杂度是 O(n)，空间复杂度也是 O(n)，二叉树的每个节点只会被访问一次
* 时间复杂度超过 69.39% 提交，空间复杂度超过 73.83% 提交

```js
// 正确版本
var inorderTraversal = function(root, res = []) {
  if (root == null) return res;
  inorderTraversal(root.left, res)
  res.push(root.val)
  inorderTraversal(root.right, res)
  return res
}
```

* 另外我也看了 angela 大神的版本，大 an 老师是这么写的，这样不用去动函数定义稍微脑筋急转弯一下子就可以曲线救国了我理解
* 时间复杂度超过 69.39% 提交，空间复杂度超过 58.72% 提交

```js
var inorderTraversal = function(root) {
  let res = []
  let inOrder = (root) => {
    if (root == null) return res;
    inOrder(root.left)
    res.push(root.val)
    inOrder(root.right)  
  }
  inOrder(root)
  return res
};
```

* 不用辅助函数和任何外部变量，单纯用原函数递归解题的写法
  * 时间复杂度超过 87.56% 提交，空间复杂度超过 30.57% 提交

```js
var inorderTraversal = function(root) {
  let res = []
  if (root == null) return res;
  res.push(...inorderTraversal(root.left))
  res.push(root.val) // 中序位置
  res.push(...inorderTraversal(root.right))
  return res
};
```

* 第二种解法：迭代，也是题目进阶中的要求，这里暂时留坑
* 第三种解法：Morris 中序遍历，这个就听都没听过了，回头再填这个。。。

## 104 二叉树的最大深度

* 这道题有很多种解法，我的思路是先跟着拉神的二叉树解题思维模式想一下，这里也再写一下
  * 第一类是遍历一遍二叉树得出答案，通过一个 `traverse` 函数配合外部变量来实现
  * 第二类是通过分解问题计算出答案，定义一个递归函数，通过子问题（子树）的答案推导出原问题的答案，如果可以，写出这个递归函数的定义，并充分利用这个函数的返回值
  * 无论使用哪一种思维模式，都要明白二叉树的每一个节点需要做什么，需要在什么时候（前中后序）做
* 第一种解法：遍历（递归）
  * 思路是遍历一遍二叉树，用一个外部变量记录每个节点所在的深度，取最大值就可以得到最大深度
  * 为什么需要在前序位置增加 `depth`，在后序位置减小 `depth`
    * 前序位置是进入一个节点的时候，后序位置是离开一个节点的时候，`depth` 记录当前递归到的节点深度
    * 把 `traverse` 理解成在二叉树上游走的一个指针，所以要这样维护
  * 至于对 `res` 的更新，放到「前 / 中 / 后序位置」都可以，只要保证在进入节点之后，离开节点之前（即 `depth` 自增之后，自减之前）就行了
  * 时间复杂度超过 61.87% 提交，空间复杂度超过 23.64% 提交

```js
var maxDepth = function(root) {
  let res = 0 // 记录最大深度
  let depth = 0 // 记录遍历到的节点的深度
  const traverse = (root) => {
    if (root == null) return;
    depth++ // 前序位置
    // 到达叶子节点，更新最大深度，这里的判断不做也可以过得去，但是时间复杂度会难看很多
    if (root.left == null && root.right == null) res = Math.max(res, depth);
    traverse(root.left)
    traverse(root.right)
    depth-- // 后序位置
  }
  traverse(root)
	return res
}
```

* 第二种解法：分解问题（DFS）
  * 一棵二叉树的最大深度可以通过子树的最大深度推导出来
  * 为什么主要的代码逻辑集中在后序位置
    * 因为这个思路正确的核心在于，确实可以通过子树的最大深度推导出原树的深度
    * 所以要首先利用递归函数的定义算出左右子树的最大深度，然后推出原树的最大深度，主要逻辑自然在后序位置
  * 时间复杂度超过 39.46% 提交，空间复杂度超过 87.62% 提交

```js
var maxDepth = function(root) {
  if (root == null) return 0;
  let leftMax = maxDepth(root.left)
  let rightMax = maxDepth(root.right)
  // 整棵树的最大深度等于左右子树的最大深度取最大值，然后再加上根节点自己
  return Math.max(leftMax, rightMax) + 1 // 后序位置
}
```

* 第三种解法：BFS

## 144. 二叉树的前序遍历

* 第一种解法：递归

  * 跟上面 #94 一样，理解了拉神的二叉树遍历框架的话，就只用改一行的顺序就可以了
  * 改默认函数定义的写法
    * 时间复杂度超过 86.73% 提交，空间复杂度超过 38.02% 提交

  ```js
  var preorderTraversal = function(root, res = []) {
    if (root == null) return res;
    res.push(root.val)
    preorderTraversal(root.left, res)
    preorderTraversal(root.right, res)
    return res
  };
  ```

  * 不动定义的写法
    * 时间复杂度超过 95.83% 提交，空间复杂度超过 95.56% 提交

  ```js
  var preorderTraversal = function(root) {
    let res = []
    let preOrder = (root) => {
      if (root == null) return res;
      res.push(root.val)
      preOrder(root.left)
      preOrder(root.right)  
    }
    preOrder(root)
    return res
  };
  ```

  * 不用辅助函数和任何外部变量，单纯用原函数递归解题的写法
    * 前序遍历的特点是，根节点的值排在首位，接着是左子树的前序遍历结果，最后是右子树的前序遍历结果
    * 一棵二叉树的前序遍历结果 = 根节点 + 左子树的前序遍历结果 + 右子树的前序遍历结果
    * 时间复杂度超过 5.25% 提交，空间复杂度超过 30.97% 提交，这个解法不常见的原因是算法的复杂度不好把控

  ```js
  var preorderTraversal = function(root) {
    let res = []
    if (root == null) return res;
    // 前序遍历的结果，root.val 在第一个
    res.push(root.val)
    // 利用函数定义，后面接着左子树的前序遍历结果
    res.push(...preorderTraversal(root.left))
    // 利用函数定义，最后接着右子树的前序遍历结果
    res.push(...preorderTraversal(root.right))
    return res
  };
  ```

## 145. 二叉树的后序遍历

* 第一种解法：递归

  * 改默认函数定义的写法
    * 时间复杂度超过 45.44% 提交，空间复杂度超过 92.45% 提交

  ```js
  var postorderTraversal = function(root, res = []) {
    if (root == null) return res;
    postorderTraversal(root.left, res)
    postorderTraversal(root.right, res)
    res.push(root.val)
    return res
  }
  ```

  * 不动定义的写法
    * 时间复杂度超过 69.81% 提交，空间复杂度超过 68.29% 提交

  ```js
  var postorderTraversal = function(root) {
    let res = []
    let postOrder = (root) => {
      if (root == null) return res;
      postOrder(root.left)
      postOrder(root.right)  
      res.push(root.val)
    }
    postOrder(root)
    return res
  };
  ```

  * 不用辅助函数和任何外部变量，单纯用原函数递归解题的写法
    * 时间复杂度超过 69.78% 提交，空间复杂度超过 34.00% 提交

  ```js
  var postorderTraversal = function(root) {
    let res = []
    if (root == null) return res;
    // 利用函数定义，后面接着左子树的前序遍历结果
    res.push(...postorderTraversal(root.left))
    // 利用函数定义，最后接着右子树的前序遍历结果
    res.push(...postorderTraversal(root.right))
    // 后序位置，root.val 在最后一个
    res.push(root.val)
    return res
  };
  ```

## 543. 二叉树的直径

