## 94. 二叉树的中序遍历

* 第一种解法：递归
* 这种就是拉神的二叉树遍历框架，直接套就完事，前提得看过拉神讲解哦，我信心满满地咔咔写上去，结果直接解答错误，只通过了 2 个测试用例，当时我就懵了

```js
// 错误版本
var inorderTraversal = function(root) {
  let res = []
  if (root == null) return res;
  inorderTraversal(root.left)
  res.push(root.val)
  inorderTraversal(root.right)
  return res
}
```

* 然后我就去看题解，发现我的跟正确的相比在形参这里就有区别，正确的是要把返回的数组当作形参传进去，但默认的模板一开始只有一个形参，我也没遇见过还可以改函数默认定义的，然后就学到了，哦原来是可以动默认函数定义的
* 递归的时间复杂度是 O(n)，空间复杂度也是 O(n)，二叉树的每个节点只会被访问一次
* 时间复杂度超过 69.39% 提交，空间复杂度超过 73.83% 提交

```js
// 正确版本
var inorderTraversal = function(root, res = []) {
  if (root == null) return res;
  inorderTraversal(root.left, res)
  res.push(root.val)
  inorderTraversal(root.right, res)
  return res
}
```

* 另外我也看了 angela 大神的版本，大 an 老师是这么写的，这样不用去动函数定义稍微脑筋急转弯一下子就可以曲线救国了我理解
* 时间复杂度超过 69.39% 提交，空间复杂度超过 58.72% 提交

```js
var inorderTraversal = function(root) {
  let res = []
  let inOrder = (root) => {
    if (root == null) return res;
    inOrder(root.left)
    res.push(root.val)
    inOrder(root.right)  
  }
  inOrder(root)
  return res
};
```

* 不用辅助函数和任何外部变量，单纯用原函数递归解题的写法
  * 时间复杂度超过 87.56% 提交，空间复杂度超过 30.57% 提交

```js
var inorderTraversal = function(root) {
  let res = []
  if (root == null) return res;
  res.push(...inorderTraversal(root.left))
  res.push(root.val) // 中序位置
  res.push(...inorderTraversal(root.right))
  return res
};
```

* 第二种解法：迭代，也是题目进阶中的要求，这里暂时留坑
* 第三种解法：Morris 中序遍历，这个就听都没听过了，回头再填这个。。。

## 104 二叉树的最大深度

* 这道题有很多种解法，我的思路是先跟着拉神的二叉树解题思维模式想一下，这里也再写一下
  * 第一类是遍历一遍二叉树得出答案，通过一个 `traverse` 函数配合外部变量来实现
  * 第二类是通过分解问题计算出答案，定义一个递归函数，通过子问题（子树）的答案推导出原问题的答案，如果可以，写出这个递归函数的定义，并充分利用这个函数的返回值
  * 无论使用哪一种思维模式，都要明白二叉树的每一个节点需要做什么，需要在什么时候（前中后序）做
* 第一种解法：遍历（递归）
  * 思路是遍历一遍二叉树，用一个外部变量记录每个节点所在的深度，取最大值就可以得到最大深度
  * 为什么需要在前序位置增加 `depth`，在后序位置减小 `depth`
    * 前序位置是进入一个节点的时候，后序位置是离开一个节点的时候，`depth` 记录当前递归到的节点深度
    * 把 `traverse` 理解成在二叉树上游走的一个指针，所以要这样维护
  * 至于对 `res` 的更新，放到「前 / 中 / 后序位置」都可以，只要保证在进入节点之后，离开节点之前（即 `depth` 自增之后，自减之前）就行了
  * 时间复杂度超过 61.87% 提交，空间复杂度超过 23.64% 提交

```js
var maxDepth = function(root) {
  let res = 0 // 记录最大深度
  let depth = 0 // 记录遍历到的节点的深度
  const traverse = (root) => {
    if (root == null) return;
    depth++ // 前序位置
    // 到达叶子节点，更新最大深度，这里的判断不做也可以过得去，但是时间复杂度会难看很多
    if (root.left == null && root.right == null) res = Math.max(res, depth);
    traverse(root.left)
    traverse(root.right)
    depth-- // 后序位置
  }
  traverse(root)
	return res
}
```

* 第二种解法：分解问题（DFS）
  * 一棵二叉树的最大深度可以通过子树的最大深度推导出来
  * 为什么主要的代码逻辑集中在后序位置
    * 因为这个思路正确的核心在于，确实可以通过子树的最大深度推导出原树的深度
    * 所以要首先利用递归函数的定义算出左右子树的最大深度，然后推出原树的最大深度，主要逻辑自然在后序位置
  * 时间复杂度超过 39.46% 提交，空间复杂度超过 87.62% 提交

```js
var maxDepth = function(root) {
  if (root == null) return 0;
  let leftMax = maxDepth(root.left)
  let rightMax = maxDepth(root.right)
  // 整棵树的最大深度等于左右子树的最大深度取最大值，然后再加上根节点自己
  return Math.max(leftMax, rightMax) + 1 // 后序位置
}
```

* 第三种解法：BFS

## 144. 二叉树的前序遍历

* 第一种解法：递归

  * 跟上面 #94 一样，理解了拉神的二叉树遍历框架的话，就只用改一行的顺序就可以了
  * 改默认函数定义的写法
    * 时间复杂度超过 86.73% 提交，空间复杂度超过 38.02% 提交

  ```js
  var preorderTraversal = function(root, res = []) {
    if (root == null) return res;
    res.push(root.val)
    preorderTraversal(root.left, res)
    preorderTraversal(root.right, res)
    return res
  };
  ```

  * 不动定义的写法
    * 时间复杂度超过 95.83% 提交，空间复杂度超过 95.56% 提交

  ```js
  var preorderTraversal = function(root) {
    let res = []
    let preOrder = (root) => {
      if (root == null) return res;
      res.push(root.val)
      preOrder(root.left)
      preOrder(root.right)  
    }
    preOrder(root)
    return res
  };
  ```

  * 不用辅助函数和任何外部变量，单纯用原函数递归解题的写法
    * 前序遍历的特点是，根节点的值排在首位，接着是左子树的前序遍历结果，最后是右子树的前序遍历结果
    * 一棵二叉树的前序遍历结果 = 根节点 + 左子树的前序遍历结果 + 右子树的前序遍历结果
    * 时间复杂度超过 5.25% 提交，空间复杂度超过 30.97% 提交，这个解法不常见的原因是算法的复杂度不好把控

  ```js
  var preorderTraversal = function(root) {
    let res = []
    if (root == null) return res;
    // 前序遍历的结果，root.val 在第一个
    res.push(root.val)
    // 利用函数定义，后面接着左子树的前序遍历结果
    res.push(...preorderTraversal(root.left))
    // 利用函数定义，最后接着右子树的前序遍历结果
    res.push(...preorderTraversal(root.right))
    return res
  };
  ```

## 145. 二叉树的后序遍历

* 第一种解法：递归

  * 改默认函数定义的写法
    * 时间复杂度超过 45.44% 提交，空间复杂度超过 92.45% 提交

  ```js
  var postorderTraversal = function(root, res = []) {
    if (root == null) return res;
    postorderTraversal(root.left, res)
    postorderTraversal(root.right, res)
    res.push(root.val)
    return res
  }
  ```

  * 不动定义的写法
    * 时间复杂度超过 69.81% 提交，空间复杂度超过 68.29% 提交

  ```js
  var postorderTraversal = function(root) {
    let res = []
    let postOrder = (root) => {
      if (root == null) return res;
      postOrder(root.left)
      postOrder(root.right)  
      res.push(root.val)
    }
    postOrder(root)
    return res
  };
  ```

  * 不用辅助函数和任何外部变量，单纯用原函数递归解题的写法
    * 时间复杂度超过 69.78% 提交，空间复杂度超过 34.00% 提交

  ```js
  var postorderTraversal = function(root) {
    let res = []
    if (root == null) return res;
    // 利用函数定义，后面接着左子树的前序遍历结果
    res.push(...postorderTraversal(root.left))
    // 利用函数定义，最后接着右子树的前序遍历结果
    res.push(...postorderTraversal(root.right))
    // 后序位置，root.val 在最后一个
    res.push(root.val)
    return res
  };
  ```

## 543. 二叉树的直径

* 二叉树的「直径」长度，就是任意两个结点之间的路径长度，最长「直径」并不一定要穿过根结点，解决这题的关键在于，**每一条二叉树的「直径」长度，就是一个节点的左右子树的最大深度之和**
* 这道题的前两种解法使用了「分解问题」的思路，因为当前节点接收并利用了子树返回的信息，这就意味着把原问题分解成了当前节点 + 左右子树的子问题
* 第一种解法：前序遍历
  * 直截了当的思路就是遍历整棵树中的每个节点，然后通过每个节点的左右子树的最大深度算出每个节点的「直径」，最后把所有「直径」求个最大值即可
  * 这个解法是正确的，但是运行时间很长，原因也很明显，`traverse` 遍历每个节点的时候还会调用递归函数 `maxDepth`，而 `maxDepth` 是要遍历子树的所有节点的，所以最坏时间复杂度是 O(n²)
  * **前序位置无法获取子树信息，所以只能让每个节点调用 `maxDepth` 函数去算子树的深度**，如果写出了这种递归套递归的解法，大概率也需要反思是不是可以通过后序遍历优化了
  * 时间复杂度超过 12.04% 提交，空间复杂度超过 11.63% 提交

```js
var diameterOfBinaryTree = function (root) {
  let maxDiameter = 0 // 记录最大直径的长度
  // 计算二叉树的最大深度，跟上面 #104 的解法一模一样
  const maxDepth = (root) => {
    if (root == null) return 0;
    let leftMax = maxDepth(root.left)
    let rightMax = maxDepth(root.right)
    return Math.max(leftMax, rightMax) + 1
  }
  // 遍历二叉树
  const traverse = (root) => {
    if (root == null) return;
    // 对每个节点计算直径
    let leftMax = maxDepth(root.left)
    let rightMax = maxDepth(root.right)
    let myDiameter = leftMax + rightMax
    maxDiameter = Math.max(maxDiameter, myDiameter)
    // 以上为前序位置
    traverse(root.left)
    traverse(root.right)
  }
  traverse(root) // 对每个节点计算直径，求最大直径
  return maxDiameter
}
```

* 第二种解法：后序遍历
  * 前序位置是刚刚进入节点的时刻，代码执行是自顶向下的，而后序位置是即将离开节点的时刻，代码执行是自底向上的
  * 前序位置的代码只能从函数参数中获取父节点传递来的数据，而后序位置的代码不仅可以获取参数数据，还可以获取到子树通过函数返回值传递回来的数据
  * 后序位置的特点是，只有后序位置才能通过返回值获取子树的信息，换句话说，**一旦发现题目和子树有关，那大概率要给函数设置合理的定义和返回值，在后序位置写代码了**
  * 优化的办法为应该把计算「直径」的逻辑放在后序位置，准确说应该是放在 `maxDepth` 的后序位置，因为 `maxDepth` 的后序位置是知道左右子树的最大深度的，这下时间复杂度只有 `maxDepth` 函数的 O(n) 了
  * 时间复杂度超过 50.98% 提交，空间复杂度超过 49.18% 提交

```js
var diameterOfBinaryTree = function (root) {
  let maxDiameter = 0 // 记录最大直径的长度
  const maxDepth = (root) => {
    if (root == null) return 0;
    let leftMax = maxDepth(root.left)
    let rightMax = maxDepth(root.right)
    
    // 后序位置，顺便计算最大直径，和 #104 的区别就在下面这两行
    let myDiameter = leftMax + rightMax
    maxDiameter = Math.max(maxDiameter, myDiameter)
    
    return Math.max(leftMax, rightMax) + 1
  }
  maxDepth(root) // 对每个节点计算直径，求最大直径
  return maxDiameter
}
```

