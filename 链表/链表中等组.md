## 19. 删除链表的倒数第 N 个结点

## 86. 分隔链表

## 142. 环形链表 II

* 这道题是简单组 #141 的进阶版，总体思路是当快慢指针相遇时，让其中任一个指针指向头节点，然后让它俩以相同速度前进，再次相遇时所在的节点位置就是环开始的位置

![22101401](../assets/22101401.jpeg)

* 假设快慢指针相遇时，慢指针 `slow` 走了 `k` 步，那么快指针 `fast` 一定走了 `2k` 步，`fast` 一定比 `slow` 多走了 `k` 步，这多走的 `k` 步其实就是 `fast` 指针在环里转圈圈，所以 `k` 的值就是环长度的「整数倍」

![22101402](../assets/22101402.jpeg)

* 假设相遇点距环的起点的距离为 `m`，那么结合上图的 `slow` 指针，环的起点距头结点 `head` 的距离为 `k - m`，也就是说如果从 `head` 前进 `k - m` 步就能到达环起点
* 巧的是，如果从相遇点继续前进 `k - m` 步，也恰好到达环起点，结合上图的 `fast` 指针，从相遇点开始走 k 步可以转回到相遇点，那走 `k - m` 步肯定就走到环起点了
* 所以，只要把快慢指针中的任一个重新指向 `head`，然后两个指针同速前进，`k - m` 步后一定会相遇，相遇之处就是环的起点了
* 时间复杂度超过 97.62% 提交，空间复杂度超过 74.63% 提交

```js
var detectCycle = function(head) {
  let slow = head, fast = head
  while (fast != null && fast.next != null) {
    slow = slow.next
    fast = fast.next.next
    if (slow == fast) break; // 相遇点
  }
  // fast 遇到空指针说明没有环
  if (fast == null || fast.next == null) {
    return null
  }
  // 含有环的情况
  slow = head // slow 重新指向头结点
  while (slow != fast) {
    slow = slow.next // 快慢指针同步前进，相交点就是环起点
    fast = fast.next
  }
  return slow
}
```



