## 19. 删除链表的倒数第 N 个结点

* 这道题的解法可由「简单组 剑指 Offer 22 题」引申而来，如果是先看到这里可以先去简单组看一下那道题再来哦
* 要删除倒数第 `n` 个节点，就得获得倒数第 `n + 1` 个节点的引用，可以用上题实现的 `getKthFromEnd` 来操作
* 注意这里又使用了虚拟头结点的技巧，也是为了防止出现空指针的情况
  * 比如说链表总共有 5 个节点，题目就让删除倒数第 5 个节点，也就是第一个节点，那按照算法逻辑，应该首先找到倒数第 6 个节点，但第一个节点前面已经没有节点了，这就会出错
  * 但有了虚拟节点 `dummy` 的存在，就避免了这个问题，能够对这种情况进行正确的删除
* 时间复杂度超过 97.75% 提交，空间复杂度超过 29.57% 提交

```js
var removeNthFromEnd = function(head, n) {
  const getKthFromEnd = (head, k) => {
    let p1 = head
    for (let i = 0; i < k; i++) {
      p1 = p1.next // p1 先走 k 步
    }
    let p2 = head
    while (p1 != null) {
      p1 = p1.next
      p2 = p2.next // p1 和 p2 同时走 n - k 步
    }
    return p2 // p2 现在指向第 n - k + 1 个节点，即倒数第 k 个节点
  }
  let dummy = new ListNode(-1) // 虚拟头结点
  dummy.next = head
  let x = getKthFromEnd(dummy, n + 1) // 删除倒数第 n 个，要先找倒数第 n + 1 个节点
  x.next = x.next.next // 删掉倒数第 n 个节点
  return dummy.next
}
```

## 86. 分隔链表

* 这道题的思路是将链表一分为二，具体来说，可以把原链表分成两个小链表，一个链表中的元素大小都小于 `x`，另一个链表中的元素都大于等于 `x`，最后再把这两条链表接到一起
* 时间复杂度超过 95.29% 提交，空间复杂度超过 29.22% 提交

```js
var partition = function(head, x) {
  let dummy1 = new ListNode(-1) // 存放小于 x 的链表的虚拟头结点
  let dummy2 = new ListNode(-1) // 存放大于等于 x 的链表的虚拟头结点
  let p1 = dummy1, p2 = dummy2 // p1, p2 指针负责生成结果链表
  let p = head // p 负责遍历原链表，类似合并两个有序链表的逻辑，这里是将一个链表分解成两个链表
  while (p != null) {
    if (p.val < x) {
      p1.next = p
      p1 = p1.next
    } else {
      p2.next = p
      p2 = p2.next
    }
    let temp = p.next // 用一个变量暂存下一个节点
    p.next = null // 断开原链表中每个节点的 next 指针
    p = temp // 将 p 指向下一个节点
  }
  p1.next = dummy2.next // 连接两个链表
  
  return dummy1.next
}
```

## 142. 环形链表 II

* 这道题是简单组 #141 的进阶版，总体思路是当快慢指针相遇时，让其中任一个指针指向头节点，然后让它俩以相同速度前进，再次相遇时所在的节点位置就是环开始的位置
* 假设快慢指针相遇时，慢指针 `slow` 走了 `k` 步，那么快指针 `fast` 一定走了 `2k` 步，`fast` 一定比 `slow` 多走了 `k` 步，这多走的 `k` 步其实就是 `fast` 指针在环里转圈圈，所以 `k` 的值就是环长度的「整数倍」

![22101401](../assets/22101401.jpeg)

* 假设相遇点距环的起点的距离为 `m`，那么结合上图的 `slow` 指针，环的起点距头结点 `head` 的距离为 `k - m`，也就是说如果从 `head` 前进 `k - m` 步就能到达环起点
* 巧的是，如果从相遇点继续前进 `k - m` 步，也恰好到达环起点，结合上图的 `fast` 指针，从相遇点开始走 k 步可以转回到相遇点，那走 `k - m` 步肯定就走到环起点了

![22101402](../assets/22101402.jpeg)

* 所以，只要把快慢指针中的任一个重新指向 `head`，然后两个指针同速前进，`k - m` 步后一定会相遇，相遇之处就是环的起点了
* 时间复杂度超过 97.62% 提交，空间复杂度超过 74.63% 提交

```js
var detectCycle = function(head) {
  let slow = head, fast = head
  while (fast != null && fast.next != null) {
    slow = slow.next
    fast = fast.next.next
    if (slow == fast) { // 快慢指针相遇，说明含有环
      fast = head // fast 重新指向头结点
      while (fast != slow) { // 快慢指针同步前进
        fast = fast.next
        slow = slow.next
      }
      return fast // 相交点就是环起点
    }
  }
  return null // 不包含环
}
```



