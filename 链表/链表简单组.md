## 21. 合并两个有序链表

* 这道题可以简单理解为合并两个递增数组的链表版本，感觉也是基础必会系列
* 第一种：双指针拉拉链
  * 拉拉链这个就是拉神 [链表双指针技巧](https://labuladong.gitee.io/algo/2/19/18/) 这篇中讲到的方法，非常形象直观易懂，需要注意的点我觉得就是「虚拟头结点」这里，也就是 `dummy` 节点，这个技巧在链表题中都很实用
  * 时间复杂度超过 44.33% 提交，空间复杂度超过 62.39% 提交

```js
var mergeTwoLists = function(l1, l2) {
  let dummy = new ListNode(-1) // 虚拟头结点，可以避免处理空指针的情况
  let p = dummy
  
  while (l1 != null && l2 != null) {
    // 比较 l1 和 l2 两个指针,将值较小的的节点接到 p 指针
    if (l1.val > l2.val) {
      p.next = l2
      l2 = l2.next
    } else {
      p.next = l1
      l1 = l1.next
    }
    p = p.next
  }
  // 如果其中一条已经接完，将另一条剩下的（不为空）接到末尾
  if (l1 != null) p.next = l1;
  if (l2 != null) p.next = l2
  
  return dummy.next
}
```

* 第二种：递归
  * 这个解法的详细讲解可以参考力扣上这位大神的[讲解](https://leetcode.cn/problems/merge-two-sorted-lists/solution/chao-xiang-xi-tu-jie-di-gui-zhi-xing-guo-cheng-21h/)，把递归的每一步都列了出来，方便需要的朋友们解惑
  * 时间复杂度超过 83.39% 提交，空间复杂度超过 22.93% 提交，时间复杂度是 O(m + n)，m 和 n 分别是 l1 和 l2 的元素个数

```js
var mergeTwoLists = function(l1, l2) {
  // 递归的结束条件，如果 l1 和 l2 中有一个为空就返回
  if (l1 == null || l2 == null) {
    return l1 == null ? l2: l1
  }
  // 如果 l1 的值 <= l2 的值，就继续递归，比较 l1.next 的值和 l2 的值
  if (l1.val <= l2.val) {
    // l1.next 和 l2 比较完后，会产生一个更小的节点 x，将 x 加到当前 l1 的后面
    l1.next = mergeTwoLists(l1.next, l2)
    return l1
  } else {
    // 如果 l1 的值 > l2 的值，就继续递归，比较 l1 的值和 l2.next 的值
    l2.next = mergeTwoLists(l1, l2.next)
    return l2
  }
}
```

## 83. 删除排序链表中的重复元素

* 这道题就是拉神讲数组双指针中快慢指针时第一个例子「#26 删除有序数组中的重复项」的[单链表版本](https://labuladong.gitee.io/algo/2/20/23/#一快慢指针技巧)

![22101201](../assets/22101201.gif)

* 双指针快慢指针解法
  * 时间复杂度超过 99.16% 提交，空间复杂度超过 61.87% 提交

```js
var deleteDuplicates = function(head) {
	if (head == null) return null;
  let slow = head, fast = head
  while (fast != null) {
    if (fast.val !== slow.val) {
      slow.next = fast
      slow = slow.next
    }
    fast = fast.next
  }
  slow.next = null // 断开与后面重复元素的连接
  return head
};
```

* 使用虚拟头结点优化，可以免去非空判定

```js
var deleteDuplicates = function(head) {
  // 区别只在这两行
  let dummy = new ListNode(-1)
  let slow = dummy, fast = dummy
  
  while (fast != null) {
    if (fast.val !== slow.val) {
      slow.next = fast
      slow = slow.next
    }
    fast = fast.next
  }
  slow.next = null // 断开与后面重复元素的连接
  return head
}
```

## 141. 环形链表

* 这道题也是拉神讲链表双指针时的例子
  * 每当慢指针 `slow` 前进一步，快指针 `fast` 就前进两步，如果 `fast` 最终遇到空指针，说明链表中没有环
  * 如果 `fast` 最终和 `slow` 相遇，那肯定是 `fast` 超过了 `slow` 一圈，说明链表中含有环
  * 时间复杂度超过 87.31% 提交，空间复杂度超过 87.38% 提交

```js
var hasCycle = function(head) {
  let slow = head, fast = head
  while (fast != null && fast.next != null) {
    slow = slow.next
    fast = fast.next.next
    if (slow == fast) return true; // 快慢指针相遇，说明含有环
  }
  return false // 不包含环
}
```

## 160. 相交链表

* 这道题还是拉神讲链表双指针时的例子，个人觉得拉神的配图超级直观易懂，拉神，yyds！

  * 如果不用额外的空间，只使用两个指针，由于两条链表的长度可能不同，两条链表之间的节点无法对应
    * 两个指针 `p1` 和 `p2` 分别在两条链表上前进，并不能**同时**走到公共节点，也就无法得到相交节点 `c1`
  * 因此通过下图这种方式，让 `p1` 和 `p2` 能够同时到达相交节点 `c1`
    * 让 `p1` 遍历完链表 `A` 之后开始遍历链表 `B`，让 `p2` 遍历完链表 `B` 之后开始遍历链表 `A`，这样进行拼接，就可以让 `p1` 和 `p2` 同时进入公共部分，也就是同时到达相交节点 `c1`

  ![22101301](../assets/22101301.jpeg)

  * 同时如果两个链表没有相交点 ，相当于 `c1` 节点是 null 空指针，也能够正确的返回 null
  * 时间复杂度超过 73.27% 提交，空间复杂度超过 49.51% 提交，时间复杂度为 `O(N)`，空间复杂度为 `O(1)`

```js
var getIntersectionNode = function(headA, headB) {
  let p1 = headA, p2 = headB // p1 指向 A 链表头结点，p2 指向 B 链表头结点
  while (p1 != p2) {
    if (p1 == null) p1 = headB; // p1 走一步，如果走到 A 链表末尾，转到 B 链表
    else p1 = p1.next;
    if (p2 == null) p2 = headA; // p2 走一步，如果走到 B 链表末尾，转到 A 链表
    else p2 = p2.next;
  }
  return p1
}
```

