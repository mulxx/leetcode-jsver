## 23. 合并 K 个升序链表

* 归并解法
  * 由于看拉神的讲解翻译不出 JavaScript 语言的版本，JS 语言没有像 Java 语言一样有现成的 PriorityQueue 优先级队列这样的列直接使用，因此借鉴大安老师的归并排序解法，也非常巧妙
  * 输入的 k 个排序链表，可以分成两部分，前 k/2 个链表和后 k/2 个链表，如果将这前 k/2 个链表和后 k/2 个链表分别合并成两个排序的链表，再将两个排序的链表合并，那么所有链表都合并了
  * 时间复杂度超过 96.00% 提交，空间复杂度超过 81.70% 提交，因为使用的是归并排序的思路，所以它的时间复杂度为 O(nlogn)，空间复杂度为 O(logn)（递归调用栈的深度为 O(logn) ）

```js
var mergeKLists = function(lists) {
  if (lists.length === 0) return null; // 数组为空情况
  
  // 合并两个有序链表逻辑，跟简单组 #21 一模一样
  const merge = (l1, l2) => {
    let dummy = new ListNode(-1)
    let p = dummy
    while (l1 != null && l2 != null) {
      if (l1.val > l2.val) {
        p.next = l2
        l2 = l2.next
      } else {
        p.next = l1
        l1 = l1.next
      }
      p = p.next
    }
    if (l1 != null) p.next = l1;
    if (l2 != null) p.next = l2;
    
    return dummy.next
  }
  
  // 归并排序逻辑
  const mergeLists = (lists, start, end) => {
    // base case 只有一个链接的情况
    if (start === end) return lists[start];
    // 将 k 个排序链表分成两部分，前 k/2 个链表和后 k/2 个链表
    let mid = start + ((end - start) >> 1)
    // 将这前 k/2 个链表和后 k/2 个链表分别合并成两个排序的链表
    let head1 = mergeLists(lists, start, mid)
    let head2 = mergeLists(lists, mid + 1, end)
    // 再将两个排序的链表合并，所有链表都合并了
    return merge(head1, head2)
  }
  return mergeLists(lists, 0, lists.length - 1)
}
```

