## 76. 最小覆盖子串

这道题是[拉神讲滑动窗口算法](https://labuladong.gitee.io/algo/1/12/)的第一道例题，一上来就是困难感觉很劝退，但是啃下来后面第二道就是中等难度了，所以豁出去拿下它了

第一种解法：滑动窗口算法

滑动窗口的思路非常简单，就是维护一个窗口，不断滑动，然后更新答案

```js
// 大致逻辑
let left = 0, right = 0
while (right < s.length) {
  window.add(s[right]) // 增大窗口
  right++
  
  while (window needs shrink) {
    window.remove(s[left]) // 缩小窗口
    left++
  }
}
```

但困扰的不是思路，而是各种细节问题，比如如何向窗口中添加新元素，如何缩小窗口，在窗口滑动的哪个阶段更新结果

滑动窗口算法代码框架如下

其中两处 `...` 表示的更新窗口数据的地方，到时候直接往里面填就行，而且这两个 `...` 处的操作分别是扩大和缩小窗口的更新操作，它们操作是完全对称的

```js
var slidingWindow = function(s) {
  let window = {}
  let left = 0, right = 0
  while (right < s.length) {
    let c = s[right] // c 是将移入窗口的字符
    right++ // 增大窗口
    ... // 进行窗口内数据的一系列更新
    
    console.log(left, right) // debug 位置
    // 判断左侧窗口是否要收缩
    while (window needs shrink) {
      let d = s[left] // d 是将移出窗口的字符
      left++ // 缩小窗口
      ... // 进行窗口内数据的一系列更新
    }
  }
}
```

这道题翻译过来是要在 `S`(source) 中找到包含 `T`(target) 中全部字母的一个子串，且这个子串一定是所有可能子串中最短的

具体到这道题的解题思路

* 第一步：在字符串 `S` 中使用双指针中的左右指针技巧，初始化 `left = right = 0`，把索引**左闭右开**区间 `[left, right)` 称为一个「窗口」
  * 理论上可以设计两端都开或者两端都闭的区间，但设计为左闭右开区间是最方便处理的
  * 因为这样初始化 `left = right = 0` 时区间 `[0, 0)` 中没有元素，但只要让 `right` 向右移动（扩大）一位，区间 `[0, 1)` 就包含一个元素 `0` 了
  * 如果设置为两端都开的区间，那么让 `right` 向右移动一位后开区间 `(0, 1)` 仍然没有元素
  * 如果设置为两端都闭的区间，那么初始区间 `[0, 0]` 就包含了一个元素
  * 这两种情况都会给边界处理带来不必要的麻烦
* 第二步：先不断地增加 `right` 指针扩大窗口 `[left, right)`，直到窗口中的字符串符合要求（包含了 `T` 中的所有字符）
* 第三步：此时，停止增加 `right`，转而不断增加 `left` 指针缩小窗口 `[left, right)`，直到窗口中的字符串不再符合要求（不包含 `T` 中的所有字符了）。同时，每次增加 `left`，都要更新一轮结果
* 第四步：重复第 2 和第 3 步，直到 `right` 到达字符串 `S` 的尽头

这个思路**第 2 步相当于在寻找一个「可行解」，然后第 3 步在优化这个「可行解」，最终找到最优解**，也就是最短的覆盖子串

这道题在套模板前需要思考几个问题

首先初始化 `window` 和 `need` 两个哈希表，记录窗口中的字符和需要凑齐的字符

再初始化 `valid` 变量为 0，`valid` 变量表示窗口中满足 `need` 条件的字符个数，如果 `valid` 和 `need.size` 的大小相同，则说明窗口已满足条件，已经完全覆盖了串 `T`

第一个：什么时候应该移动 `right` 扩大窗口？窗口加入字符时，应该更新哪些数据

* 如果一个字符进入窗口，应该增加 `window` 计数器

第二个：什么时候窗口应该暂停扩大，开始移动 `left` 缩小窗口？从窗口移出字符时，应该更新哪些数据

* 当 `valid` 满足 `need` 时应该收缩窗口
* 如果一个字符将移出窗口的时候，应该减少 `window` 计数器

第三个：我们要的结果应该在扩大窗口时还是缩小窗口时进行更新

* 应该在收缩窗口的时候更新最终结果

时间复杂度超过 15.81% 提交，空间复杂度超过 28.22% 提交，时间复杂度为 O(n)，n 是输入字符串的长度

```js
var minWindow = function(s, t) {
  let need = {} // 记录 t 中需要的字符出现次数
  let window = {} // 记录「窗口」中相应字符的出现次数
  for (let c of t) {
    if (need[c] === undefined) need[c] = 0;
    need[c]++ // 统计需要的字符
    window[c] = 0
  }
  // 使用 left 和 right 变量初始化窗口的两端，区间 [left, right) 是左闭右开的，初始情况窗口没有任何元素
  let left = 0, right = 0
  let valid = 0 // valid 表示窗口中满足 need 条件的字符个数
  let start = 0, len = Infinity // 记录最小覆盖子串的起始索引及长度
  while (right < s.length) { // 开始滑动
    let c = s[right] // c 是将移入窗口的字符
    right++ // 扩大窗口
    // 进行窗口内数据的一系列更新
    if (need[c] !== undefined) {
      window[c]++ // 当前字符在需要的字符中，则更新当前窗口统计
      if (window[c] === need[c]) valid++; // 当前窗口和需要的字符匹配时，验证数量增加 1
    }
    // 判断左侧窗口是否要收缩：当验证数量与需要的字符个数一致时
    while (valid === Object.keys(need).length) {
      // 在这里更新最小覆盖子串（更新最终结果）
      if (right - left < len) {
        start = left
        len = right - left
      }
      let d = s[left] // d 是即将移出窗口的字符
      left++ // 缩小窗口
      // 进行窗口内数据的一系列更新
      if (need[d] !== undefined) {
        if (window[d] === need[d]) valid--;
        window[d]--
      }
    }
  }
  return len === Infinity ? "" : s.substr(start, len) // 返回最小覆盖子串
}
```

需要注意的是，当发现某个字符在 `window` 的数量满足了 `need` 的需要，就要更新 `valid`，表示有一个字符已经满足要求

而且能发现，两次对窗口内数据的更新操作是完全对称的

当 `valid == need.size()` 时，说明 `T` 中所有字符已经被覆盖，已经得到一个可行的覆盖子串，现在应该开始收缩窗口了，以便得到「最小覆盖子串」

移动 `left` 收缩窗口时，窗口内的字符都是可行解，所以应该在收缩窗口的阶段进行最小覆盖子串的更新，以便从可行解中找到长度最短的最终结果