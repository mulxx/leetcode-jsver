## 13. 罗马数字转整数

这道题如果从来没接触过罗马数字规则的话看到这么题目描述这么多字已经后悔点进来要做了，没错说的就是我，做了一会心理建设才决定接着做下去的无阅读能力菜狗本狗

第一种：暴力 switch 解法

这个解法就是我感觉这道题应该有更简便的解法，只有几行代码就可以搞定的那种，但直觉上我第一时间只能想到这么做，而且一开始想的还更离谱，我甚至在想把 4 / 9 / 40 那六种情况写进 switch 判断里，然后发现好像不太可行。。。

这种解法只有一个细节需要注意，就是想明白这六种情况的逻辑然后把它转变成代码就可以了，别看这么多行但 98% 都是无脑写上去的

时间复杂度超过 99.01% 提交，空间复杂度超过 70.15% 提交

```js
var romanToInt = function(s) {
  let res = 0
  const switchNum = (s) => {
    switch (s) {
      case 'I':
        return 1;
        break
      case 'V':
        return 5;
        break
      case 'X':
        return 10;
        break
      case 'L':
        return 50;
        break
      case 'C':
        return 100;
        break
      case 'D':
        return 500;
        break
      case 'M':
        return 1000;
        break
      default:
        return 0;
    }
  }
  for (let i = s.length - 1; i >= 0; i--) {
    // 这里唯一需要想明白的就是以下这两行对吧，这里一上来我还写错了因为没转过劲来
    if (switchNum(s[i]) < switchNum(s[i + 1])) {
      res -= switchNum(s[i])
    } else {
      res += switchNum(s[i])
    }
  }
  return res
};
```

第二种：Map 解法

这种就是把上面 switch 语句换成 Map 结构映射，然后把从右向左遍历换个方向变成从左向右遍历而已

时间复杂度超过 48.56% 提交，空间复杂度超过 69.37% 提交

```js
var romanToInt = function(s) {
  let res = 0
  let map = {
    I: 1,
    V: 5,
    X: 10,
    L: 50,
    C: 100,
    D: 500,
    M: 1000
  }
  for (let i = 0; i < s.length; i++) {
    if (map[s[i]] < map[s[i + 1]]) {
      res -= map[s[i]]
    } else {
      res += map[s[i]]
    }
  }
  return res
}
```

第三种：究极暴力纯 if-else 解法

这个是看到[官方题解下面](https://leetcode.cn/problems/roman-to-integer/solution/luo-ma-shu-zi-zhuan-zheng-shu-by-leetcod-w55p/)一位大神 Elon Tang 的答案，不瞒各位我最开始也是这么想的，六种特殊情况都直接判断好，比第一种还纯，如果大家看到这个答案相信可以博君一笑，这里就不写出来了

## 202. 快乐数

这道题我个人觉得跟题目完全无关，在没看懂规律之前一点都不快乐，我想了一会想到递归的思路但感觉会比较麻烦不太对劲，直接就去看题解了

这里的套路个人感觉[官方的题解](https://leetcode.cn/problems/happy-number/solution/kuai-le-shu-by-leetcode-solution/)分析的最透彻，不管使用哈希表还是快慢指针解题的前提得是先分析出题目的套路，把它的原题描述转化成一个规律，也就是不断重复求每个数字每个位置上的数字的平方和会出现哪几种情况

* 第一种：最终会得到 1
* 第二种：最终会进入循环
* 第三种：值会越来越大，最后接近无穷大（实际是不会发生的，但也得看懂分析才知道）

在明白这几种情况的前提后，剩下的解法确实就是简单的难度了不假

第一种：快慢指针解法

这种解法和链表简单组 #141 是完全一样的套路，具体讲解可以参考拉神讲[链表双指针的这篇](https://labuladong.gitee.io/algo/1/4/)，保证清晰易懂，之所以强行归到字符串系列中也是因为这种解法有一个 `toString()` 的操作就很勉强

时间复杂度超过 75.94% 提交，空间复杂度超过 23.71% 提交

```js
var isHappy = function(n) {
  // 首先是求每个数字每个位置上的数字的平方和的函数，这种借鉴来的写法个人觉得有点秀，用到 ES6 的求幂运算符和数组 reduce 方法
  const getNext = (n) => {
    return n
    	.toString()
    	.split("")
    	.map((i) => i ** 2)
    	.reduce((prev, curr) => prev + curr)
  }
  // 这部分就完全是判断是否成环的思路，跟链表是一模一样的
  let slow = n, fast = getNext(n)
  while (fast !== slow && fast !== 1) { // 这里只判断快慢指针是否相等也能过去
    slow = getNext(slow)
    fast = getNext(getNext(fast))
  }
  return fast === 1
}
```

第二种：哈希表解法（待填坑）

## 412. Fizz Buzz

这道题是朋友一次外包面试的原题，感觉这道题是简单题内部也偏简单的那种难度

第一种：纯纯暴力 if-else 解法

这个解法是第一次听到直接想到的，完全没有讲一句的必要那种

时间复杂度超过 58.03% 提交，空间复杂度超过 58.80% 提交，时间复杂度为 O(n)，空间复杂度为 O(1)

```js
var fizzBuzz = function(n) {
	const res = []
	for (let i = 1; i <= n; i++) {
		if (i % 3 === 0 && i % 5 !== 0) {
			res.push("Fizz")
		} else if (i % 3 !== 0 && i % 5 === 0) {
			res.push("Buzz")
		} else if (i % 3 === 0 && i % 5 === 0) {
      // else if (i % 15 === 0) // 这样写也可以
			res.push("FizzBuzz")
		} else {
			res.push(i.toString())
      // res.push(i + '') // 这样写也可以
		}
	}
	return res
}
```

