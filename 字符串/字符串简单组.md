## 13. 罗马数字转整数

这道题如果从来没接触过罗马数字规则的话看到这么题目描述这么多字已经后悔点进来要做了，没错说的就是我，做了一会心理建设才决定接着做下去的无阅读能力菜狗本狗

第一种：暴力 switch 解法

这个解法就是我感觉这道题应该有更简便的解法，只有几行代码就可以搞定的那种，但直觉上我第一时间只能想到这么做，而且一开始想的还更离谱，我甚至在想把 4 / 9 / 40 那六种情况写进 switch 判断里，然后发现好像不太可行。。。

这种解法只有一个细节需要注意，就是想明白这六种情况的逻辑然后把它转变成代码就可以了，别看这么多行但 98% 都是无脑写上去的

时间复杂度超过 99.01% 提交，空间复杂度超过 70.15% 提交

```js
var romanToInt = function(s) {
  let res = 0
  const switchNum = (s) => {
    switch (s) {
      case 'I':
        return 1;
        break
      case 'V':
        return 5;
        break
      case 'X':
        return 10;
        break
      case 'L':
        return 50;
        break
      case 'C':
        return 100;
        break
      case 'D':
        return 500;
        break
      case 'M':
        return 1000;
        break
      default:
        return 0;
    }
  }
  for (let i = s.length - 1; i >= 0; i--) {
    // 这里唯一需要想明白的就是以下这两行对吧，这里一上来我还写错了因为没转过劲来
    if (switchNum(s[i]) < switchNum(s[i + 1])) {
      res -= switchNum(s[i])
    } else {
      res += switchNum(s[i])
    }
  }
  return res
};
```

第二种：Map 解法

这种就是把上面 switch 语句换成 Map 结构映射，然后把从右向左遍历换个方向变成从左向右遍历而已

时间复杂度超过 48.56% 提交，空间复杂度超过 69.37% 提交

```js
var romanToInt = function(s) {
  let res = 0
  let map = {
    I: 1,
    V: 5,
    X: 10,
    L: 50,
    C: 100,
    D: 500,
    M: 1000
  }
  for (let i = 0; i < s.length; i++) {
    if (map[s[i]] < map[s[i + 1]]) {
      res -= map[s[i]]
    } else {
      res += map[s[i]]
    }
  }
  return res
}
```

第三种：究极暴力纯 if-else 解法

这个是看到[官方题解下面](https://leetcode.cn/problems/roman-to-integer/solution/luo-ma-shu-zi-zhuan-zheng-shu-by-leetcod-w55p/)一位大神 Elon Tang 的答案，不瞒各位我最开始也是这么想的，六种特殊情况都直接判断好，比第一种还纯，如果大家看到这个答案相信可以博君一笑，这里就不写出来了

## 14. 最长公共前缀

第一种解法：转数组法

这种思路是我第一个想出来的思路，其实就是遍历加 every API 折腾折腾，毫无技术含量

时间复杂度超过 74.09% 提交，空间复杂度超过 18.16% 提交

```js
var longestCommonPrefix = function(strs) {
  const arr = []
  for (let i of strs) {
    arr.push(i.split(''))
  }
  const temp = []
  for (let i = 0; i < arr[0].length; i++) {
    if (arr.every(j => j[i] === arr[0][i])) temp.push(arr[0][i]);
    else return temp.join('')
  }
  return temp.join('')
};
```

第二种解法：转 Set 法

转数组之后自然而然就想到 Set 来做了，其实也比较简单配合 while 循环就可以

时间复杂度超过 55.05% 提交，空间复杂度超过 9.99% 提交

```js
var longestCommonPrefix = function(strs) {
  let i = 0, res = ''
  while (i < strs[0].length) {
    const arr = []
    for (let j of strs) {
      arr.push(j[i])
    }
    const set = new Set(arr)
    if (set.size === 1) {
      res += strs[0][i]
    } else {
      return res
    }
    i++
  }
  return res
};
```

第三种解法：待填坑

## 20. 有效的括号

根据[拉神的讲解](https://labuladong.gitee.io/algo/4/33/130/)，这道题可以先降低一下难度作为引子，**如果只有一种括号 `()`**，应该如何判断字符串组成的括号是否有效

假设字符串中只有圆括号，如果想让字符串有效，那么必须做到「每个右括号 `)` 的左边必须有一个左括号 `(` 和它匹配」

简化版的解法如下

```js
var isValid = function(str) {
  let left = 0 // 待匹配的左括号数量
  for (let i = 0; i < str.length; i++) {
    if (str[i] === '(') left++;
    else left--; // 遇到右括号
    
    if (left === -1) return false; // 右括号太多
  }
  return left === 0 // 是否所有的左括号都被匹配了
}
```

如果只有圆括号，这样就能正确判断有效性，但多种括号的情况下，直接照搬这种思路是不行的，`[(])` 显然是无效的

第一种：使用栈解法

为了加大存储的信息量，可以使用栈来模仿上述思路，栈是一种先进后出的数据结构，处理括号问题的时候尤其有用

这里用一个名为 `left` 的栈代替之前思路中的 `left` 变量，遇到左括号就入栈，遇到右括号就去栈中寻找最近的左括号，看是否匹配

时间复杂度超过 50.73% 提交，空间复杂度超过 56.70% 提交

```js
var isValid = function(str) {
  if (str.length % 2 === 1) return false; // 一个小优化点，如果字符串长度不是偶数，那肯定不匹配
  const left = []
  const leftOf = (c) => {
    if (c === '}') return '{';
    if (c === ')') return '(';
    return '['
  }
  for (let c of str) {
    if (c === '(' || c === '{' || c === '[') {
      left.push(c)
    } else { // 字符 c 是右括号
      if (left.length && leftOf(c) === left[left.length - 1]) {
        left.pop()
      } else {
        return false; // 和最近的左括号不匹配
      }
    }
  }
  return left.length === 0 // 是否所有的左括号都被匹配了
}
```

另一种栈解法

时间复杂度超过 99.79% 提交，空间复杂度超过 35.83% 提交

```js
var isValid = function(str) {
  if (str.length % 2 === 1) return false;
  let map = {
    "(": ")",
    "{": "}",
    "[": "]"
  }
  const stack = []
  for (let c of str) {
    if (map[stack[stack.length - 1]] === c) {
      stack.pop()
    } else {
      stack.push(c)
    }
  }
  return stack.length === 0
}
```

## 58. 最后一个单词的长度

第一种解法：迭代 for 循环

这种是我自己想出来的笨方法，两层嵌套 for 循环时间复杂度肯定不好看

时间复杂度超过 42.75% 提交，空间复杂度超过 21.64% 提交

```js
var lengthOfLastWord = function(s) {
  for (let i = s.length - 1; i >= 0; i--) {
    for (let j = i; j >= 0; j--) {
      if (s[i] !== " " && (s[j - 1] === " " || j === 0)) {
        return i - j + 1
      }
    }
  }
}
```

第二种解法：单层 for 循环

这种是借鉴[这位大神](https://leetcode.cn/problems/length-of-last-word/solution/by-okisama-rl1v/)的解法，感觉比我写的第一种好不少

时间复杂度超过 84.01% 提交，空间复杂度超过 14.43% 提交

```js
var lengthOfLastWord = function(s) {
  let res = 0
  for (let i = s.length - 1; i >= 0; i--) {
    if (s[i] !== ' ') res++;
    if (res !== 0 && s[i] === ' ') break;
  }
  return res
};
```

第三种解法：一行 trim 法

时间复杂度超过 94.11% 提交，空间复杂度超过 25.26% 提交

```js
var lengthOfLastWord = function(s) {
  return s.trim().split(' ').at(-1).length
  // 下面写法也可以
  return s.trimEnd().split(' ').at(-1).length
  return s.trim().split(' ').slice(-1).length
}
```

第四种解法：一行 filter 法

时间复杂度超过 65.09% 提交，空间复杂度超过 53.83% 提交

```js
var lengthOfLastWord = function(s) {
  return s.split(' ').filter(i => i !== '').pop().length
}
```

## 171. Excel 表列符号

第一种解法：进制转换法

这道题我看了一会想用一个 Map 结构来存下 26 个字母和对应的数字。。。发现这种思路实在太笨就去看了题解，原来还是得用 `charCodeAt()` API 方便哦，一开始想了一秒钟这个却没想到这么用。。。。无语

[官方题解](https://leetcode.cn/problems/excel-sheet-column-number/solution/excelbiao-lie-xu-hao-by-leetcode-solutio-r29l/)的思路非常清晰，其实就是把 26 进制转换为十进制，按照这个思路就应该无需多说了，直接咔咔写就完事了

时间复杂度超过 74.09% 提交，空间复杂度超过 92.93% 提交

```js
var titleToNumber = function(columnTitle) {
  let res = 0, multiple = 1
  for (let i = columnTitle.length - 1; i >= 0; i--) {
    let num = columnTitle[i].charCodeAt() - 'A'.charCodeAt() + 1
    res += num * multiple
    multiple *= 26
  }
  return res
};
```

## 125. 验证回文串

字符串的回文串这道题不用多说，肯定是面试里的超级常考题，有数字的，有字符串的，有数组的，我也实际在面试中遇到过，核心思想肯定就是双指针，如果本身会回文串的题，上来开始写时候先说个用双指针方法写，这道题个人感觉50分就已经到手了

这道题跟简单的回文串相比多了一个 trim 的操作，需要先处理一下字符串中多余的字符和格式，这里我看题解有几种不同解法，我个人会采用正则的办法来处理，原因有两点，一是正则一行就能搞定，代码比其他方法少很多，二是正则我觉得也算一个知识点，会正则在面试中可以当作一个小加分项个人觉得，而且在实际工作中也能用到，稍微啃下感觉肯定不亏

第一种：使用双指针

时间复杂度超过 32.44% 提交，空间复杂度超过 73.18% 提交

```js
var isPalindrome = function(s) {
  // 正则表达式后的 g 是一个表示全局搜索选项或标记，将在整个字符串查找并返回所有匹配结果（引用自 MDN 文档）
  s = s.replace(/[^a-zA-Z0-9]/g, "").replace(/\s/g, "").toLowerCase()
  let l = 0, r = s.length - 1
  while (l < r) {
    if (s[l] !== s[r]) return false;
    l++
    r--
  }
  return true
}
```

第二种：使用数组 reverse + join API

这种方式就是利用字符串没有的 `reverse()` 方法，先把字符串转成数组翻转后再转回成字符串，一共只需两行

时间复杂度超过 46.57% 提交，空间复杂度超过 37.68% 提交

```js
var isPalindrome = function(s) {
  s = s.replace(/[^a-zA-Z0-9]/g, "").replace(/\s/g, "").toLowerCase()
  return s === [...s].reverse().join("")
}
```

## 344. 反转字符串

这道题也可以用左右双指针来解决，[拉神在讲这道题](https://labuladong.gitee.io/algo/1/5/)的时候归类到数组双指针技巧里去了，我这就按照官方标签来吧放在字符串系列中了

时间复杂度超过 96.26% 提交，空间复杂度超过 99.41% 提交

```js
var reverseString = function(s) {
  let left = 0, right = s.length - 1
  while (left < right) {
    [s[left], s[right]] = [s[right], s[left]] // 这里是解构赋值的交换变量用法
    left++
    right--
  }
}
```

## 383. 赎金信

第一种解法：哈希表法

这种思路就是先遍历一遍 `magazine` 生成哈希表，然后再遍历一遍 `ransomNote` 不断从哈希表中删除，如果为 0 或者不存在就返回 `false`

时间复杂度超过 22.47% 提交，空间复杂度超过 84.88% 提交

```js
var canConstruct = function(ransomNote, magazine) {
  const map = new Map()
  for (let i = 0; i < magazine.length; i++) {
    if (map.has(magazine[i])) map.set(magazine[i], map.get(magazine[i]) + 1);
    else map.set(magazine[i], 1)
  }
  for (let j = 0; j < ransomNote.length; j++) {
    if (map.has(ransomNote[j]) && map.get(ransomNote[j]) > 0) map.set(ransomNote[j], map.get(ransomNote[j]) - 1);
    else return false;
  }
  return true;
};
```

第二种解法：replace API 法

这种是[这位大神](https://leetcode.cn/problems/ransom-note/solution/dai-ma-jian-ji-yi-chong-huan-bu-cuo-de-j-ghn5/)的思路，我个人觉得挺秀的，也想不到，正好也复习一下 `replace` API，MDN 链接[在这里](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/replace)方便参考

时间复杂度超过 76.00% 提交，空间复杂度超过 31.20% 提交

```js
var canConstruct = function(ransomNote, magazine) {
  for (let i of magazine) {
    if (ransomNote.includes(i)) {
      ransomNote = ransomNote.replace(i, '')
      // 原作者用的是正则写法，如下所示
      // ransomNote = ransomNote.replace(new RegExp(i), '')
    }
  }
  return ransomNote.length === 0
};
```

第三种解法：字符统计法

这种是[官方题解](https://leetcode.cn/problems/ransom-note/solution/shu-jin-xin-by-leetcode-solution-ji8a/)的思路，但我觉得刚看到有点懵，[这位大神](https://leetcode.cn/problems/ransom-note/solution/by-clever-austinzya-gd7u/)的手绘图解就非常非常帮上忙，强烈推荐，另 `charCodeAt` API 的 [MDN 链接](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/charCodeAt)也一并附上方便参考

时间复杂度超过 55.62% 提交，空间复杂度超过 39.07% 提交

```js
var canConstruct = function(ransomNote, magazine) {
  if (ransomNote.length > magazine.length) return false;
  const arr = new Array(26).fill(0)
  for (let i of magazine) {
    arr[i.charCodeAt() - 'a'.charCodeAt()]++
  }
  for (let j of ransomNote) {
    arr[j.charCodeAt() - 'a'.charCodeAt()]--
    if (arr[j.charCodeAt() - 'a'.charCodeAt()] < 0) return false;
  }
  return true
};
```

## 389. 找不同

在说解法之前，先说因为读题没完全理解踩到的一个坑，就是题目中 `s` 的字符串可以是重复的，虽然两个示例中看不出来，但是题目也没写死新增的字符不能是第一个字符串中已有的，所以我上来的第一次如下尝试就只能过 2 / 54 个测试用例。。。。

```js
var findTheDifference = function(s, t) {
  const arr1 = s.split("")
  const arr2 = t.split("")
  for (let i of arr2) {
    if (arr1.indexOf(i) === -1) return i;
  }
};
```

第一种：转数组后用数组方法和下标解法

这个思路就很简单，先把两个字符串转为数组，然后遍历第一个数组，看第二个数组是否存在第一个数组中的元素，如果不存在，直接返回此元素，如果不存在，将此元素从第二个数组中删除，最后剩下的那个元素就是多出的字符

时间复杂度超过 44.23% 提交，空间复杂度超过 32.88% 提交

```js
var findTheDifference = function(s, t) {
  const arr1 = s.split("")
  const arr2 = t.split("")
  for (let i = 0; i < arr1.length; i++) {
    let index = arr2.indexOf(arr1[i])
    if (index === -1) return arr2[index];
    else arr2.splice(index, 1);
  }
  return arr2.join("")
};
```

第二种：异或位运算解法

此解法跟数组简单组 #136 中的异或位运算是同一思路

异或运算时两个相同的数字为 0：`n ^ n = 0` ，0 和任何数异或都为那个数：`n ^ 0 = n`，因此所有偶数次的都会相互抵消变为 0，再和其他数消消乐，留下结果

比如一个数组是 [4, 1, 2, 1, 2] ，`4 ^ 1 ^ 2 ^ 1 ^ 2` => `1 ^ 1 ^ 2 ^ 2 ^ 4` => `0 ^ 2 ^ 2 ^ 4` => `2 ^ 2 ^ 4` => `0 ^ 4` => `4`

时间复杂度超过 80.42% 提交，空间复杂度超过 73.04% 提交，时间复杂度为 O(n)，空间复杂度为 O(1)

```js
var findTheDifference = function(s, t) {
  let temp = 0
  // 以 "abcd" 和 "abcde" 为例
  for (let i of s) {
    // String.charCodeAt(index) 方法将字符串转为 Unicode 码，index 默认为 0
    temp ^= i.charCodeAt()
  }
  // "abcd" 遍历完位运算后 temp 的值为 4
  for (let i of t) {
    temp ^= i.charCodeAt()
  }
  // 再与 "abcde" 遍历完位运算后 temp 的值为 101，对应的字符为 "e"
  // String.fromCharCode() 方法将 Unicode 码转回为一个字符
  return String.fromCharCode(temp)
};
```

第三种：求和解法

这种思路采用了一部分的第二种的思路，都使用 Unicode 码作为核心，这种思路分别将两个字符串中每个字符的 ASCII 码求和，然后相减再转回字符

时间复杂度超过 80.42% 提交，空间复杂度超过 74.24% 提交，时间复杂度为 O(n)，空间复杂度为 O(1)

```js
var findTheDifference = function(s, t) {
  let temp1 = 0, temp2 = 0
  for (let i of s) {
    temp1 += i.charCodeAt()
  }
  for (let i of t) {
    temp2 += i.charCodeAt()
  }
  return String.fromCharCode(temp2 - temp1)
};
```

## 409. 最长回文串

这道题说实话虽然是简单难度但是我自己没想出来怎么解。。。题解中看到[这位大神的比喻](https://leetcode.cn/problems/longest-palindrome/solution/yong-da-pai-de-si-lu-lai-ji-suan-zui-chang-hui-wen/)是最易懂的

第一种解法：打牌

题目翻译一下其实就是要计算有多少对相同的字符，类比成打牌，抽到一对牌就打出来，当所有的牌都抽完了，手里如果还有剩余的未成对的牌，还能抽出一张

如果当前抽到的牌已经在手里有了，那么把手里的那个牌和当前的牌凑成一对打出来，结果 +2，最后如果手里还有牌，结果 +1，下面代码就直接不用注释了，真的牛批

时间复杂度超过 76.63% 提交，空间复杂度超过 28.14% 提交

```js
var longestPalindrome = function(s) {
  const map = new Map()
  const arr = s.split("")
  let count = 0
  for (let i of arr) {
    if (map.has(i)) {
      map.delete(i)
      count += 2
    } else {
      map.set(i)
    }
  }
  return count + (map.size > 0 ? 1 : 0)
}
```

## 412. Fizz Buzz

这道题是朋友一次外包面试的原题，感觉这道题是简单题内部也偏简单的那种难度

第一种：纯纯暴力 if-else 解法

这个解法是第一次看到直接想到的，完全没有讲一句的必要那种

时间复杂度超过 58.03% 提交，空间复杂度超过 58.80% 提交，时间复杂度为 O(n)，空间复杂度为 O(1)

```js
var fizzBuzz = function(n) {
	const res = []
	for (let i = 1; i <= n; i++) {
		if (i % 3 === 0 && i % 5 !== 0) {
			res.push("Fizz")
		} else if (i % 3 !== 0 && i % 5 === 0) {
			res.push("Buzz")
		} else if (i % 3 === 0 && i % 5 === 0) {
      // else if (i % 15 === 0) // 这样写也可以
			res.push("FizzBuzz")
		} else {
			res.push(i.toString())
      // res.push(i + '') // 这样写也可以
		}
	}
	return res
}
```

## 434. 字符串中的单词数

第一种解法：前导空格法

这个思路是[安神的解法](https://leetcode.cn/problems/number-of-segments-in-a-string/solution/5ju-dai-ma-gao-ding-si-lu-fei-chang-jian-722i/)，确实有点巧妙的我也想不到，单词的特点是前面是空格，如果当前遍历到的字符不是空格，就算作起始，给计数器 +1

时间复杂度超过 99.48% 提交，空间复杂度超过 28.53% 提交

```js
var countSegments = function(s) {
  let count = 0
  s = " " + s // 在最前面加上空格是为了简化后面的判断条件
  for (let i = 0; i < s.length; i++) {
    if (s[i] !== " " && s[i - 1] === " ") count++; // 当前字符不为空格且前一个字符为空格，就算作起始
  }
  return count
}
```

第二种解法：原地法

这个思路跟第一种基本一样，但不用小技巧在最前面加一个空格，如果当前遍历到的字符不是空格，且当前字符是第一个字符或者当前字符的前一个字符为空格，给计数器 +1

时间复杂度超过 77.23% 提交，空间复杂度超过 73.56% 提交，时间复杂度为 O(n)，空间复杂度为 O(1)

```js
var countSegments = function(s) {
  let count = 0
  for (let i = 0; i < s.length; i++) {
    if (s[i] !== " " && (s[i - 1] === " " || i === 0)) count++;
  }
  return count
}
```

## 520. 检测大写字母

第一种解法：暴力法

这种思路就是用 ASCII 码，也没啥说的，大写字母 A - Z 的 ASCII 码范围是 [65, 90]，小写字母 a - z 的 ASCII 码范围是 [97, 122]，知道这个就 OK 了

时间复杂度超过 48.97% 提交，空间复杂度超过 6.59% 提交

```js
var detectCapitalUse = function(word) {
  const arr = []
  for (let i of word) {
    arr.push(i.charCodeAt())
  }
  if (arr.every(i => i >= 65 && i <= 90)) return true;
  else if (arr.every(i => i >= 97 && i <= 122)) return true;
  else if (arr.filter(i => i >= 65 && i <= 90).length === 1 && word.indexOf(String.fromCharCode(arr.map(j => j >= 65 && j <= 90))) === 0) return true;
  else return false;
};
```

## 557. 反转字符串中的单词 III

第一种解法：转数组法

这种思路就是最暴力的通过数组 `reverse()` API 来做，非常清晰易懂了属于是

时间复杂度超过 55.11% 提交，空间复杂度超过 30.59% 提交

```js
var reverseWords = function(s) {
  const temp = s.split(' '), arr = []
  for (let i of temp) {
    arr.push(i.split('').reverse().join(''))
  }
  return arr.join(' ').toString()
};
```

第二种解法：数组双指针法

这种思路就是不用 `reverse()` API，用从两侧向中间的双指针来替代，时间复杂度没有第一种好看

时间复杂度超过 39.55% 提交，空间复杂度超过 100.00% 提交

```js
var reverseWords = function(s) {
  const arr = s.split(' '), res = []
  for (let word of arr) {
    const temp = word.split('')
    let i = 0, j = temp.length - 1
    while (i < j) {
      [temp[i], temp[j]] = [temp[j], temp[i]]
      i++
      j--
    }
    res.push(temp.join(''))
  }
  return res.join(' ')
};
```

## 657. 机器人能否返回原点

这道题就主观感受可能是我做过的 120 道题里难度最简单的 5% 之一了。。。

第一种解法：暴力法

我感觉读完题有种感觉不管这个字符串多花里胡哨，只要遍历一次，最后向上和向下的字符数量相等，且向左和向右的字符数量相等，就等于回到原点了，所以就用两个变量表示竖直方向和水平方向上的绝对位移距离加上一次遍历就可以了

时间复杂度超过 88.60% 提交，空间复杂度超过 26.94% 提交

```js
var judgeCircle = function(moves) {
  let vertical = 0, horizontal = 0
  for (let i = 0; i < moves.length; i++) {
    if (moves[i] === 'U') vertical++;
    if (moves[i] === 'D') vertical--;
    if (moves[i] === 'L') horizontal++;
    if (moves[i] === 'R') horizontal--;
  }
  if (vertical === 0 && horizontal === 0) return true;
  return false
};
```

第二种解法：一行法

这种我肯定是想不出来的，借鉴一下[题解大神](https://leetcode.cn/problems/robot-return-to-origin/solution/dai-ma-jian-ji-yi-chong-huan-bu-cuo-de-j-5mgo/)的解法吧

时间复杂度超过 88.60% 提交，空间复杂度超过 6.22% 提交

```js
var judgeCircle = function(moves) {
    // 判断 L.count === R.count && U.count === D.count
    return moves.split('L').length === moves.split('R').length && moves.split('U').length === moves.split('D').length
};
```

## 709. 转换成小写字母

第一种解法：toLowerCase API 法

这种是我看完题感觉不敢相信又发现原来真的这需要这一下就能通过了，下意识觉得不可能这么简单结果是我想多了。。。

时间复杂度超过 62.93% 提交，空间复杂度超过 37.07% 提交

```js
var toLowerCase = function(s) {
  return s.toLowerCase()
};
```

第二种解法：自行实现转换 API 法

这种是[官方题解](https://leetcode.cn/problems/to-lower-case/solution/zhuan-huan-cheng-xiao-xie-zi-mu-by-leetc-5e29/)的思路，我个人觉得这种解法需要知道一个前置知识是得需要直到大写字母和小写字母的 ASCII 码范围，我完全不知道，所以就只能膜拜了

注：大写字母 A - Z 的 ASCII 码范围是 [65, 90]，小写字母 a - z 的 ASCII 码范围是 [97, 122]，每个字符大小写相差 32

时间复杂度超过 18.05% 提交，空间复杂度超过 5.37% 提交

```js
var toLowerCase = function(s) {
  const arr = []
  for (let i of s) {
    if (i.charCodeAt() >= 65 && i.charCodeAt() <= 90) {
      i = String.fromCharCode(i.charCodeAt() | 32)
    }
    arr.push(i)
  }
  return arr.join('')
};
```

另外也有[一位大神](https://leetcode.cn/problems/to-lower-case/solution/jsshua-ti-mian-shi-ti-jie-by-distracted-ocgut/)也用的同样思路，只是写法上稍有不同，也一并放在这里供参考吧

时间复杂度超过 89.76% 提交，空间复杂度超过 22.44% 提交

```js
var toLowerCase = function(s) {
  let str = ''
  s.split('').map(i => {
    if (i.charCodeAt() >= 65 && i.charCodeAt() <= 90) {
      str += String.fromCodePoint(+(i.charCodeAt()) + 32);
    } else {
      str += i 
    }
  })
  return str
};
```

## 771. 宝石与石头

第一种解法：转数组遍历法

这种是我自己想出来的解法，思路就一句话，把俩字符串转成数组后通过遍历和 `includes` API 计数

时间复杂度超过 36.07% 提交，空间复杂度超过 60.70% 提交

```js
var numJewelsInStones = function(jewels, stones) {
  const jewArr = jewels.split("")
  const stonesArr = stones.split("")
  let count = 0
  for (let i = 0; i < stonesArr.length; i++) {
    if (jewArr.includes(stonesArr[i])) count++
  }
  return count
};
```

第二种解法：暴力双循环法

这种还是我想出来的笨比解法，就是嵌套循环遍历，时间复杂度也不咋好看

时间复杂度超过 36.07% 提交，空间复杂度超过 60.70% 提交

```js
var numJewelsInStones = function(jewels, stones) {
  let count = 0
  for (let i = 0; i < jewels.length; i++) {
    for (let j = 0; j < stones.length; j++) {
      if (stones[j] === jewels[i]) count++
    }
  }
  return count
};
```

第三种解法：filter + includes 一行法

这种是借鉴这位[大神的解法](https://leetcode.cn/problems/jewels-and-stones/solution/filter-includes1xing-dai-ma-chao-85-by-mantoufan/)，写法给我秀麻了，思路是先用 `Array.from()` 将 `stones` 字符串转为数组

然后再用数组 `filter` 方法找到 `jewels` 存在的字母，最后返回过滤后的数组长度

此处引用自 [MDN](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/includes)：`String.prototype.includes()` 方法执行**区分大小写**的搜索，以确定是否可以在另一个字符串中找到一个字符串，并根据情况返回 `true` 或 `false`

时间复杂度超过 91.50% 提交，空间复杂度超过 61.58% 提交

```js
var numJewelsInStones = function(jewels, stones) {
  return Array.from(stones).filter(i => jewels.includes(i)).length
}
```

第四种解法：Set 解法

这种是借鉴这位[大神的解法](https://leetcode.cn/problems/jewels-and-stones/solution/98-qiao-yong-set-you-ya-shi-xian-bao-shi-yu-shi-to/)，我确实没想到还可以用 Set 数据结构来做这道题

时间复杂度超过 96.77% 提交，空间复杂度超过 51.02% 提交

```js
var numJewelsInStones = function(jewels, stones) {
  let count = 0
  for (let i of stones) jewels.includes(i) && count++; // 这种写法我确实是第一次见，膜拜一下
  return count
}
```

使用 Set 结构的稍微变种写法

时间复杂度超过 96.77% 提交，空间复杂度超过 21.99% 提交

```js
var numJewelsInStones = function(jewels, stones) {
  let count = 0, set = new Set(jewels)
  for (let i of stones) set.has(i) && count++;
  return count
}
```

第五种解法：哈希表法（待填坑）

## 796. 旋转字符串

第一种解法：模拟法

这种思路就是用 while 循环将字符串转为数组不停从前面 `shift` 再 `push` 到后面，没什么技巧可言就

时间复杂度超过 39.41% 提交，空间复杂度超过 12.81% 提交

```js
var rotateString = function(s, goal) {
  let i = 0, arr = s.split('')
  while (i < s.length) {
    let alphabet = arr.shift()
    arr.push(alphabet)
    if (arr.join('') === goal) return true;
    i++
  }
  return false
};
```

另不用数组 API 的话还可以用 `String.slice()` API 来做，时间复杂度肯定要好一些

时间复杂度超过 62.93% 提交，空间复杂度超过 19.51% 提交

```js
var rotateString = function(s, goal) {
  let i = 0
  while (i < s.length) {
    if (s === goal) return true;
    else s = s.slice(1) + s[0];
    i++
  }
  return false
};
```

第二种解法：拼接法

这种是[这位大神](https://leetcode.cn/problems/rotate-string/solution/javascriptban-jie-ti-si-lu-by-ityou-o-ta62/)的思路，个人觉得这种思路是我最喜欢的，推荐给大家

时间复杂度超过 85.37% 提交，空间复杂度超过 88.29% 提交

```js
var rotateString = function(s, goal) {
  if (s.length !== goal.length) return false;
  if ((s + s).includes(goal)) return true;
  return false;
};
```

## 821. 字符的最短距离

第一种解法：转数组法

这种是自己的思路，大概意思就是先把目标字符出现的所有下标放到一个数组中，然后剩下就是操作这个数组和原字符串的长度，通过一个 while 循环配合 `Math.min()` API 得到每一位的最小值

时间复杂度超过 79.57% 提交，空间复杂度超过 8.94% 提交

```js
var shortestToChar = function(s, c) {
  const temp = [], res = []
  for (let i = 0; i < s.length; i++) {
    if (s[i] === c) temp.push(i)
  }
  let i = 0
  while (i < s.length) {
    let dist = []
    for (let j of temp) {
      dist.push(Math.abs(i - j))
    }
    res.push(Math.min(...dist))
    i++
  }
  return res
}
```

## 859. 亲密字符串

第一种解法：暴力法

这种思路就是硬解，把所有 case 都考虑进去就自然可以通过，只不过我被卡了几次，数一下就当个乐呵吧

一开始我先把三种示例中的都考虑进去提交之后只过了 27 / 34 的测试用例，`"abcaa" "abcbb"` 的这种就过不去了，然后把这种又考虑进去之后又过了 33 / 34 的测试用例，`"ab" "babbb"` 的这种过不去，我读题的时候怎么也没想到 `s` 和 `goal` 的长度还可以不同的，最后都考虑进去了就 OK 了，说起来怪不得这道题在现在此时此刻只有 34.5% 的通过率，有的确实不容易一下就想到啊

时间复杂度超过 23.85% 提交，空间复杂度超过 80.00% 提交

```js
var buddyStrings = function(s, goal) {
  if (s === goal) { // 两个字符串相等的情况
    for (let i = 0; i < s.length; i++) {
      if (s.lastIndexOf(s[i]) !== i) return true;
    }
    return false
  }
  if (s.length !== goal.length) return false; // 两个字符串不相等的情况
  let count = 0, tempa = [], tempb = [] // 数出两个字符串不同字母的数量和值
  for (let i = 0; i < s.length; i++) {
    if (s[i] === goal[i]) continue;
    else {
      tempa.push(s[i])
      tempb.push(goal[i])
      count++
    }
  }
  if (count === 2 && tempa.join('') === tempb.reverse().join('')) return true;
  return false;
}
```

## 917. 仅仅反转字母

第一种解法：charCodeAt() 双指针法

这种是自己的思路，跟本篇里好几道都采用相同思路判断是否是大写和小写字母，只不过用双指针来做

时间复杂度超过 25.87% 提交，空间复杂度超过 16.78% 提交

```js
var reverseOnlyLetters = function(s) {
  let arr = s.split('')
  let l = 0, r = arr.length - 1
  const isChar = (char) => {
    if ((arr[char].charCodeAt() >= 65 && arr[char].charCodeAt() <= 90) || (arr[char].charCodeAt() >= 97 && arr[char].charCodeAt() <= 122)) return true;
    else return false;
  }
  while (l <= r) {
    if (!isChar(l)) {
      l++
    } else if (!isChar(r)) {
      r--
    } else if (isChar(l) && isChar(r)) {
      [arr[l], arr[r]] = [arr[r], arr[l]]
      l++
      r--
    }
  }
  return arr.join('')
};
```

## 1002. 查找共用字符

第一种解法：笨比暴力法

这种是我自己的思路，经过多次尝试才最终踉踉跄跄通过。。。纯笨比思路舔着脸放在这里让大家见笑了，一部分思路参考本组 #709 和 #1832 ASCII 码

时间复杂度超过 35.32% 提交，空间复杂度超过 17.89% 提交

```js
var commonChars = function(words) {
  const res = [], len = words.length
  const map = new Map()
  for (let i = 97; i <= 122; i++) {
    map.set(String.fromCharCode(i), 0)
  }
  for (let word of words) {
    new Set(word).forEach(i => {
      if (map.has(i)) map.set(i, map.get(i) + 1);
      else map.set(i, 1)
    })
  }
  map.forEach((value, key) => {
    if (value === len) {
      let count = 0, arr = []
      words.forEach(word => {
        arr.push(word.split('').filter(i => i === key).length)
      })
      let min = Math.min(...arr)
      for (let i = 0; i < min; i++) {
        res.push(key)
      }
    }
  })
  return res
};
```

第二种解法：待填坑（今天实在心情不太好，暂时得过且过一天日后再回来填坑吧）

## 1108. IP 地址无效化

第一种解法：一行 relaceAll 法

这种就是用 `String.replaceAll()` API，感觉类似 Word 里的搜索和替换

时间复杂度超过 32.09% 提交，空间复杂度超过 79.54% 提交

```js
var defangIPaddr = function(address) {
  return address.replaceAll('.', '[.]')
};
```

第二种解法：正则法

正则表达式中 `.` 前面的 `\` 表示必须寻找字面字符 `.` ，表达式后的 `g` 是一个表示全局搜索选项或标记，将在整个字符串查找并返回所有匹配结果

时间复杂度超过 100.00% 提交，空间复杂度超过 5.58% 提交

```js
var defangIPaddr = function(address) {
  return address.replace(/\./g, '[.]')
};
```

第三种解法：遍历拼接法

这种就是通过一个空字符遍历原字符串不断拼接而成，也没啥技巧可言

时间复杂度超过 6.98% 提交，空间复杂度超过 64.19% 提交

```js
var defangIPaddr = function(address) {
  let res = ""
  for (let i = 0; i < address.length; i++) {
    if (address[i] === '.') res += '[.]';
    else res += address[i];
  }
  console.log(res)
  return res
};
```

第四种解法：数组拼接法

这种也是一行 API 法，先将原字符串分割成数组，再拼接回字符串

时间复杂度超过 85.12% 提交，空间复杂度超过 86.98% 提交

```js
var defangIPaddr = function(address) {
  return address.split('.').join('[.]')
};
```

## 1154. 一年中的第几天

这道题看到有闰年的概念直接梦回十年前大一了。。。如果也碰巧有科班专业的朋友们看到可能能知道我在说啥，就正好回忆一下闰年是怎么定义的，果然忘了。。。

根据百科定义，闰年的定义为

* 普通闰年：公历年份是4的倍数，且不是100的倍数的，为闰年（如2004年、2020年等就是闰年）
* 世纪闰年：公历年份是整百数的，必须是400的倍数才是闰年（如1900年不是闰年，2000年是闰年）

第一种解法：直接法

虽然题目思路简单无需动脑，但代码里还是有两个小细节需要注意的，所以也还是有点意思的

时间复杂度超过 66.38% 提交，空间复杂度超过 71.55% 提交，时间复杂度为 O(1)，空间复杂度为 O(1)

```js
var dayOfYear = function(date) {
  let res = 0
  const year = +date.slice(0, 4) // 细节一：这里需要用 + 将截取出的字符串转为数字
  const month = +date.slice(5, 7)
  const day = +date.slice(8)
  const daysArr = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]
  if ((year % 4 === 0 && year % 100 !== 0) || year % 400 === 0) daysArr[1]++;
  for (let i = 0; i < month - 1; i++) { // 细节二：这里遍历的终点是 month - 1 而不是 month
    res += daysArr[i]
  }
  res += day
  return res
};
```

## 1417. 重新格式化字符串

第一种解法：笨比双指针法

这种是今天下班后在单位没走多待了一会偷偷写的思路，很笨很暴力，不怕笑话了也

时间复杂度超过 84.09% 提交，空间复杂度超过 45.46% 提交

```js
var reformat = function(s) {
  if (s.length === 1) return s;
  const chars = [], nums = [], arr = []
  for (let i of s) {
    if (Number.isInteger(parseInt(i))) nums.push(parseInt(i));
    else chars.push(i);
  }
  if (chars.length === 0 || nums.length === 0) return '';
  if (Math.abs(chars.length - nums.length) > 1) return '';
  let i = 0, j = 0
  if (chars.length > nums.length) {
    arr.push(chars[i])
    i++
  }
  if (nums.length > chars.length) {
    arr.push(nums[j])
    j++
  }
  while (i < chars.length && j < nums.length) {
    if (i < j) {
      arr.push(chars[i])
      i++
    } else if (j < i) {
      arr.push(nums[j])
      j++
    } else {
      if (chars.length > nums.length) {
        arr.push(chars[i])
        i++
      } else {
        arr.push(nums[j])
        j++
      }
    }
  }
  if (arr.length === chars.length + nums.length - 1) {
    if (i === chars.length) arr.push(nums[j]);
    if (j === nums.length) arr.push(chars[i])
    return arr.join('')
  }
  return ''
};
```

## 1436. 旅行终点站

第一种解法：暴力法

这种是我自己想出来的，这道题我自己翻译一下的话其实就是在这个二维数组的每个元素的第二项中找出一个在第一项中找不到的就是终点站了

出发站和终点站都只有一个，出发站只可能在每个元素的第一项中，终点站只可能在每个元素的第二项中，整个数组中出现两次的就肯定是沿途站

时间复杂度超过 75.34% 提交，空间复杂度超过 43.83% 提交

```js
var destCity = function(paths) {
  const arr1 = []
  const arr2 = []
  for (let i of paths) {
    arr1.push(i[0])
    arr2.push(i[1])
  }
  for (let i of arr2) {
    if (!arr1.includes(i)) return i;
  }
};
```

第二种解法：铺平数组法

这种还是我自己想出来的，这种就是把二维数组铺平，然后在数组的偶数项里找在铺平数组中出现次数只为一次的即为终点站

时间复杂度超过 75.34% 提交，空间复杂度超过 86.30% 提交

```js
var destCity = function(paths) {
  const arr = paths.flat()
  for (let i = 0; i < arr.length; i++) {
    // 注意虽然是要找「偶数项」但下标是「奇数」所以要写成 i % 2 === 1 才对劲
    if ((i % 2 === 1) && (arr.indexOf(arr[i]) === arr.lastIndexOf(arr[i]))) return arr[i]
  }
};
```

第三种解法：哈希表法（待填坑）

这种是[官方题解](https://leetcode.cn/problems/destination-city/solution/lu-xing-zhong-dian-zhan-by-leetcode-solu-pscd/)提到的

## 1446. 连续字符

第一种解法：遍历法

这种思路就是最暴力的解法我觉得，也不需要解释了貌似

时间复杂度超过 79.55% 提交，空间复杂度超过 47.73% 提交

```js
var maxPower = function(s) {
  let max = 0, count = 1
  for (let i = 0; i < s.length; i++) {
    if (s[i + 1] === s[i]) count++;
    else {
      max = Math.max(max, count)
      count = 1
    }
  }
  return max
};
```

第二种解法：双指针法

这种思路可能跟其他的双指针法稍有些不同，主要在初始化值时候，其中 fast 被我初始化为 1，结果 max 也被初始化为 1，其他我猜应该和大神们的双指针解法差不多吧

时间复杂度超过 89.77% 提交，空间复杂度超过 90.91% 提交

```js
var maxPower = function(s) {
  let slow = 0, fast = 1, max = 1
  while (slow < s.length && fast < s.length) {
    if (s[fast] !== s[slow]) {
      slow = fast
      fast++
    } else {
      fast++
      max = Math.max(max, fast - slow)
    }
  }
  return max
};
```

第三种解法：正则一行法

这种是[这位大神](https://leetcode.cn/problems/consecutive-characters/solution/bian-li-ji-shu-zheng-ze-biao-da-shi-by-l-d1d0/)的思路，我完全没想到，主要也是正则规则我还是没了解多少。。。膜拜一下

时间复杂度超过 51.14% 提交，空间复杂度超过 23.86% 提交

```js
var maxPower = function(s) {
  return Math.max(...s.match(/(\w)\1{0,}/g).map(i => i.length))
};
```

## 1507. 转变日期格式

第一种解法：暴力法

这种思路就是对月份使用哈希表，对日手动转换一下，剩下的拼起来就好了，完全没技术含量捏

时间复杂度超过 90.32% 提交，空间复杂度超过 93.55% 提交

```js
var reformatDate = function(date) {
  const months = new Map();
  months.set('Jan', '01');
  months.set('Feb', '02');
  months.set('Mar', '03');
  months.set('Apr', '04');
  months.set('May', '05');
  months.set('Jun', '06');
  months.set('Jul', '07');
  months.set('Aug', '08');
  months.set('Sep', '09');
  months.set('Oct', '10');
  months.set('Nov', '11');
  months.set('Dec', '12');
  const temp = date.split(' '), arr = []
  const year = temp[2]
  arr.push(year)
  const month = months.get(temp[1])
  arr.push(month)
  let day = temp[0].slice(0, temp[0].length - 2);
  if (day < 10) day = '0' + day;
  arr.push(day)
  return arr.join('-')
};
```

## 1528. 重新排列字符串

第一种解法：暴力解

读完题后我一下就想起来我的第一次用到给二维数组 sort 的那道题了，就是数组中等组的 #347 的第一种解法，这个解法跟那道题相似度非常非常高，如有需要推荐连刷捏

这里有一个小细节需要注意，就是 `map.set()` 方法的先后顺序不能反哦

时间复杂度超过 63.08% 提交，空间复杂度超过 6.15% 提交

```js
var restoreString = function(s, indices) {
  const map = new Map()
  for (let i = 0; i < s.length; i++) {
    map.set(indices[i], s[i])
  }
  const arr = Array.from(map)
  arr.sort((a, b) => a[0] - b[0])
  return arr.map(i => i[1]).join('')
};
```

第二种解法：模拟法

这种思路说实话我个人感觉没有第一种简单易懂似的，相比起来感觉稍微有一点点脑筋急转弯，脑子有点痒了呢。。。

时间复杂度超过 7.69% 提交，空间复杂度超过 53.85% 提交

```js
var restoreString = function(s, indices) {
  const arr = new Array(s.length);
  for (let i = 0; i < s.length; i++) {
    arr[indices[i]] = s.charAt(i)
  }
  return arr.join('')
};
```

## 1662. 检查两个字符串数组是否相等

第一种解法：暴力法

这种是我自己的思路，没啥别的，就是遍历然后用加号拼接起来，在 MDN 的[官方 concat API](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/concat) 中提到「强烈建议使用[赋值操作符](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Addition)代替 `concat` 方法」，所以这里使用 + 来写

时间复杂度超过 86.51% 提交，空间复杂度超过 19.10% 提交

```js
var arrayStringsAreEqual = function(word1, word2) {
  let str1 = '', str2 = ''
  for (let i of word1) str1 += i;
  for (let i of word2) str2 += i;
  if (str1 === str2) return true;
  return false
};
```

第二种解法：join API 法

这种也是自己想出来的，也没啥需要讲解的应该

时间复杂度超过 69.32% 提交，空间复杂度超过 74.68% 提交

```js
var arrayStringsAreEqual = function(word1, word2) {
  let str1 = word1.join(''), str2 = word2.join('')
  return str1 === str2
};
```

第三种解法：reduce API 法

这种是借鉴题解中的思路，也非常直观易懂

时间复杂度超过 86.51% 提交，空间复杂度超过 99.46% 提交

```js
var arrayStringsAreEqual = function(word1, word2) {
  let str1 = word1.reduce((prev, curr) => prev + curr, "")
  let str2 = word2.reduce((prev, curr) => prev + curr, "")
  return str1 === str2
};
```

第四种解法：正则法

这种是借鉴题解中[这位大神](https://leetcode.cn/problems/check-if-two-string-arrays-are-equivalent/solution/dai-ma-jian-ji-yi-chong-huan-bu-cuo-de-j-3uzr/)的思路，我确实想不出来

时间复杂度超过 10.54% 提交，空间复杂度超过 5.11% 提交

```js
var arrayStringsAreEqual = function(word1, word2) {
  let str1 = word1.reduce((prev, curr) => prev + curr, "")
  let str2 = word2.reduce((prev, curr) => prev + curr, "")
  let reg = new RegExp('^'+str1+'$', 'g');
  return reg.test(str2)
};
```

第五种解法：遍历法

这种是[官方题解](https://leetcode.cn/problems/check-if-two-string-arrays-are-equivalent/submissions/)的思路，我也确实没想到，可以做到直接在 word1 和 word2 上进行对比

时间复杂度超过 44.75% 提交，空间复杂度超过 52.47% 提交

```js
var arrayStringsAreEqual = function(word1, word2) {
  let p1 = 0, p2 = 0, i = 0, j = 0
  while (p1 < word1.length && p2 < word2.length) {
    if (word1[p1][i] !== word2[p2][j]) return false;
    i++
    if (i === word1[p1].length) {
      p1++
      i = 0
    }
    j++
    if (j === word2[p2].length) {
      p2++
      j = 0
    }
  }
  return p1 === word1.length && p2 === word2.length
};
```

## 1684. 统计一致字符串的数目

第一种解法：for 循环法

这种解法是我自己想的，感觉明显不够优雅

时间复杂度超过 35.59% 提交，空间复杂度超过 12.85% 提交

```js
var countConsistentStrings = function(allowed, words) {
  let count = 0
  const arr = allowed.split("")
  for (let i of words) {
    const innerArr = new Set(i.split(""))
    count += 1
    for (let j of innerArr) {
      if (!arr.includes(j)) {
        count -= 1
        break;
      }
    }
  }
  return count
};
```

第二种解法：every + includes API 解法

时间复杂度超过 56.01% 提交，空间复杂度超过 19.15% 提交

```js
var countConsistentStrings = function(allowed, words) {
  let count = 0
  for (let i of words) {
    let res = i.split('').every(j => allowed.includes(j))
    if (res) count++;
  }
  return count
};
```

第三种解法：正则法

这种有两位大神都用了这种思路，分别膜拜一下先，第一种思路的嵌套遍历的时间复杂度是 O(n²) 比较高

[第一位大神](https://leetcode.cn/problems/count-the-number-of-consistent-strings/solution/shi-yong-zheng-ze-by-huahuadavids-ckey/)讲到正则的思路是比如 `allowed` 是 `abc`，正则就是 `reg = /(a|b|c)*/`，遍历 `words`，使用正则替换每个字符串，如果是空就代表满足条件，这种计算为空的数量的方式比嵌套遍历时间复杂度更低

时间复杂度超过 67.14% 提交，空间复杂度超过 76.06% 提交

```js
var countConsistentStrings = function(allowed, words) {
  let reg = '(', count = 0
  for (let i of allowed) reg += i + '|'
  reg = reg.slice(0, reg.length - 1)
  reg += ')*'
  reg = new RegExp(reg)
  for (let j of words) {
    let pattern = j.replace(reg, '')
    if (!pattern) count++
  }
  return count
};
```

[第二位大神](https://leetcode.cn/problems/count-the-number-of-consistent-strings/solution/javascriptban-jie-ti-si-lu-by-ityou-o-2fyl/)的正则解法是以下写法，思路基本是一样的

时间复杂度超过 15.28% 提交，空间复杂度超过 14.43% 提交

```js
var countConsistentStrings = function(allowed, words) {
  let reg = '', count = 0
  for (let i of allowed) reg += i + '|' // 拼出一个正则表达式
  for (let j of words) {
    let pattern = new RegExp(reg.substring(0, reg.length - 1), 'g')
    // 替换完毕所有和 allowed 相关的就只剩下无关的
    if (j.replace(pattern, '') === '') count++;
  }
  return count
};
```

## 1704. 判断字符串的两半是否相似

第一种解法：暴力法

这种思路就是转成数组，通过遍历和 `includes` API 来计数，时间复杂度肯定不好看

时间复杂度超过 15.25% 提交，空间复杂度超过 13.56% 提交

```js
var halvesAreAlike = function(s) {
  const arr = ['a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U']
  const temp = s.split(''), len = s.length
  const a = temp.slice(0, len / 2), b = temp.slice(len / 2)
  let countA = 0, countB = 0
  for (let i of a) {
    if (arr.includes(i)) countA++;
  }
  for (let i of b) {
    if (arr.includes(i)) countB++;
  }
  return countA === countB
};
```

第二种解法：一次遍历法

这种思路就是不拆分成前后半部分，通过一次遍历和一个数组筛选出元音的下标，然后直接判断数组中前半部分的数量是否等于数组长度的一半就可以

时间复杂度超过 71.19% 提交，空间复杂度超过 20.34% 提交

```js
var halvesAreAlike = function(s) {
  const arr = ['a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U']
  const indexes = [], len = s.length
  for (let i = 0; i < len; i++) {
    if (arr.includes(s[i])) indexes.push(i + 1); // 这里我有意给下标加了 1
  }
  return indexes.filter(j => j <= len / 2).length === indexes.length / 2
};
```

## 1768. 交替合并字符串

第一种解法：双指针法

这道题看完后一下就想到了双指针拉拉链法，具体到思路和数组简单组 #88 几乎完全一样，我也直接转数组来做了，并且有 `&&` 和 `||` 两种写法，正好也就当复习拉拉链了还挺好

时间复杂度超过 89.05% 提交，空间复杂度超过 43.78% 提交

```js
// && 写法
var mergeAlternately = function(word1, word2) {
  const arr = [], temp1 = word1.split(''), temp2 = word2.split('')
  let i = 0, j = 0
  while (i < temp1.length && j < temp2.length) {
    if (i <= j) {
      arr.push(temp1[i])
      i++
    } else {
      arr.push(temp2[j])
      j++
    }
  }
  return arr.concat(temp1.slice(i)).concat(temp2.slice(j)).join('')
};
```

时间复杂度超过 76.62% 提交，空间复杂度超过 15.42% 提交

```js
// || 写法
var mergeAlternately = function(word1, word2) {
  const arr = [], temp1 = word1.split(''), temp2 = word2.split('')
  let i = 0, j = 0
  while (i < temp1.length || j < temp2.length) {
    if (i === temp1.length) {
      arr.push(temp2[j])
      j++
    } else if (j === temp2.length) {
      arr.push(temp1[i])
      i++
    } else if (i <= j) {
      arr.push(temp1[i])
      i++
    } else {
      arr.push(temp2[j])
      j++
    }
  }
  return arr.join('')
}; 
```

## 1796. 字符串第二大的数字

第一种解法：数组 + Set 法

这种思路是自己想的，先转数组筛出数字，再用 Set 去重，但最后只有字母的情况没想到，也就是 set 的长度要小于等于 1 而不是只等于 1

时间复杂度超过 91.65% 提交，空间复杂度超过 34.71% 提交

```js
var secondHighest = function(s) {
  const arr = s.split(''), temp = []
  for (let i of arr) {
    if (!Number.isNaN(Number(i))) temp.push(Number(i))
  }
  const set = [...new Set(temp)]
  set.sort((a, b) => b - a)
  if (set.length <= 1) return -1;
  else return set[1]
};
```

另外不用数组画蛇添足的话还可以这样写。。。

```js
var secondHighest = function(s) {
  const temp = []
  for (let i = 0; i < s.length; i++) {
    if (!Number.isNaN(Number(s[i]))) temp.push(Number(s[i]))
  }
  // 剩余部分完全一致
};
```

第二种解法：最大和次大变量法

这种我没想出来，这是官方题解的思路，也是很多其他题解大神们采用的思路，我看到用两个变量后就自己试了一下，感觉比第一种多少更酷一点。。。

时间复杂度超过 42.36% 提交，空间复杂度超过 54.84% 提交

```js
var secondHighest = function(s) {
  let max = -1, subMax = -1
  for (let i = 0; i < s.length; i++) {
    if (!Number.isNaN(Number(s[i]))) {
      if (Number(s[i]) > subMax && Number(s[i]) < max) {
        subMax = Number(s[i])
      } else if (Number(s[i]) > max) {
        subMax = max
        max = Number(s[i])
      }
    }
  }
  return subMax;
};
```

## 1812. 判断国际象棋棋盘中一个格子的颜色

第一中解法：Map 法

这道题思路很简单，翻译一下就是如果横轴和纵轴数字之和是奇数就返回 `true`，偶数就返回 `false`

因为字母一共只有 8 个，所以先用笨比解法来

时间复杂度超过 42.68% 提交，空间复杂度超过 73.17% 提交

```js
var squareIsWhite = function(coordinates) {
  const map = new Map()
  map.set('a', 1)
  map.set('b', 2)
  map.set('c', 3)
  map.set('d', 4)
  map.set('e', 5)
  map.set('f', 6)
  map.set('g', 7)
  map.set('h', 8)
  const arr = coordinates.split('')
  return (map.get(arr[0]) + Number(arr[1])) % 2 !== 0
};
```

第二种解法：charCodeAt API 法

这种思路就和上面 #171 的解法是同一思路，借用这个 API 也能得到小写字母对应的数字

时间复杂度超过 69.51% 提交，空间复杂度超过 65.85% 提交

```js
var squareIsWhite = function(coordinates) {
  const arr = coordinates.split('')
  return ((arr[0].charCodeAt() - 'a'.charCodeAt() + 1) + Number(arr[1])) % 2 !== 0
};
```

## 1816. 截断句子

第一种解法：转数组一行法

这种思路就没啥说的，堆 API 就可以了

时间复杂度超过 78.26% 提交，空间复杂度超过 83.70% 提交

```js
var truncateSentence = function(s, k) {
  return s.split(" ").slice(0, k).join(' ')
};
```

另这种思路还在[官方题解评论区](https://leetcode.cn/problems/truncate-sentence/solution/jie-duan-ju-zi-by-leetcode-solution-d4ts/)中看到用正则匹配的感觉很秀，因此膜拜一下

```js
var truncateSentence = function(s, k) {
  return s.match(/\S+/g).slice(0, k).join(' ')
};
```

第二种解法：遍历空格法

这种思路就不用转数组，直接遍历找空格，当空格计数达到 k 时直接截取，但有一种情况我一开始没想到就是截取整个单词列表时这时计数是永远不会达到 k 的，需要最后补充这种情况

时间复杂度超过 78.26% 提交，空间复杂度超过 89.13% 提交

```js
var truncateSentence = function(s, k) {
  let count = 0
  for (let i = 0; i < s.length; i++) {
    if (s[i] === ' ') count++;
    if (count === k) return s.substring(0, i)
  }
  return s // 这里需要稍微注意补充
};
```

## 1832. 判断句子是否为全字母句

第一种解法：暴力法

这种是自己的思路，首先知道小写字母的 ASCII 码为 97-122 后再加上 `String.fromCharCode()` API 就可以了，这道题和上面 #709 的第二种解法有异曲同工之处，稍微推荐您连刷以强化效果捏

时间复杂度超过 52.60% 提交，空间复杂度超过 56.31% 提交

```js
var checkIfPangram = function(sentence) {
  if (sentence.length < 26) return false;
  const map = new Map()
  for (let i = 97; i <= 122; i++) {
    map.set(String.fromCharCode(i), 0)
  }
  for (let i = 0; i < sentence.length; i++) {
    let char = sentence[i]
    if (map.has(char)) map.set(char, map.get(char) + 1);
    else map.set(char, 1)
  }
  return Array.from(map).every(i => i[1] >= 1)
};
```

第二种解法：Set 法

这种自己的写法是这样的，但还有更简洁更秀的写法

时间复杂度超过 13.11% 提交，空间复杂度超过 81.03% 提交

```js
var checkIfPangram = function(sentence) {
  const set = new Set()
  for (let i = 0; i < sentence.length; i++) {
    set.add(sentence[i])
  }
  return set.size === 26
};
```

比如[这位大神](https://leetcode.cn/problems/check-if-the-sentence-is-pangram/solution/dai-ma-jian-ji-yi-chong-huan-bu-cuo-de-j-jvi0/)的写法可以用一行来做

```js
var checkIfPangram = function(sentence) {
  return new Set(sentence).size === 26
};
```

## 1859. 将句子排序

第一种解法：转数组法

这种思路我上来理所应当的想到哈希表法，然后有点出乎我意外的只通过了 43 / 45 的测试用例，`s = z1 z2 z3` 这种情况就过不去。。。。然后才反应过来直接用数组不就完事了，我是傻逼

时间复杂度超过 26.97% 提交，空间复杂度超过 96.63% 提交

```js
// 这种是错误哈希表法
var sortSentence = function(s) {
  const map = new Map(), arr = s.split(' ')
  for (let i of arr) {
    let word = i.slice(0, i.length - 1)
    let number = i.slice(i.length - 1, i.length)
    map.set(word, number)
  }
  const newArr = Array.from(map).sort((a, b) => a[1] - b[1])
  return newArr.map(i => i[0]).join(' ')
};
```

```js
var sortSentence = function(s) {
  const arr = [], temp = s.split(' ')
  for (let i of temp) {
    let word = i.slice(0, i.length - 1)
    let number = i.slice(i.length - 1, i.length)
    arr.push([word, number])
  }
  return arr.sort((a, b) => a[1] - b[1]).map(i => i[0]).join(' ')
};
```

## 1903. 字符串中的最大奇数

第一种解法：脑筋急转弯法

这种思路不是我想出来的，是我用了究极笨比双层 for 循环没写出来之后忍不住看了题解才知道还有这种解法，思路就是[灵神](https://leetcode.cn/problems/largest-odd-number-in-string/solution/zhao-zui-hou-yi-ge-qi-shu-wei-zhi-by-end-j98d/)的这句话「由于奇数的最后一个数字是奇数，从后往前找到第一个奇数数字，删掉后面的字符，剩下的就是最大的奇数」，由此我就按这个思路顺利通过了，帅，灵神，帅！（这句是谁的烂梗我不说嘿嘿）

时间复杂度超过 42.05% 提交，空间复杂度超过 55.68% 提交

```js
var largestOddNumber = function(num) {
  for (let i = num.length - 1; i >= 0; i--) {
    if (num[i] % 2 !== 0) {
      return num.slice(0, i + 1)
    }
  }
  return ""
};
```

## 1941. 检查是否所有字符出现次数相同

第一种解法：哈希表 + Set 法

这种思路就是一句话概括，先转哈希表 -> 再到数组 -> 再到 Set，就 OK 了

时间复杂度超过 97.33% 提交，空间复杂度超过 32.00% 提交

```js
var areOccurrencesEqual = function(s) {
  const map = new Map()
  for (let i of s) {
    if (map.has(i)) map.set(i, map.get(i) + 1);
    else map.set(i, 1)
  }
  const arr = Array.from(map).map(i => i[1])
  const set = new Set(arr)
  return set.size === 1
};
```

第二种解法：待填坑

## 1957. 删除字符使字符串变好

第一种解法：转数组法

这种思路就是比较笨的解法我理解，就是先转数组之后然后遍历，满足连续三个相同就跳过而已

时间复杂度超过 44.23% 提交，空间复杂度超过 17.31% 提交

```js
var makeFancyString = function(s) {
  if (s.length < 3) return s;
  const temp = s.split(''), arr = [temp[0], temp[1]]
  for (let i = 2; i < temp.length; i++) {
    if (temp[i] === temp[i - 1] && temp[i] === temp[i - 2]) continue;
    else arr.push(temp[i])
  }
  return arr.join('')
};
```

## 1967. 作为子字符串出现在单词中的字符串数目

第一种解法：includes API 法

这种就没啥说的，最简单无脑的方法

时间复杂度超过 100.00% 提交，空间复杂度超过 48.57% 提交

```js
var numOfStrings = function(patterns, word) {
  let count = 0
  for (let i of patterns) {
    if (word.includes(i)) count++;
  }
  return count
};
```

另这种思路也有一行写法

```js
var numOfStrings = function(patterns, word) {
  return patterns.filter(i => word.includes(i)).length
};
```

第二种解法：indexOf API 法

这种我一开始确实没想到，因此这里放上 [MDN 链接](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/indexOf)，我完全没想起来这个 API 可以搜索子字符串

时间复杂度超过 54.29% 提交，空间复杂度超过 25.71% 提交

```js
var numOfStrings = function(patterns, word) {
  let count = 0
  for (let i of patterns) {
    if (word.indexOf(i) !== -1) count++;
  }
  return count
};
```

```js
var numOfStrings = function(patterns, word) {
  return patterns.filter(i => word.indexOf(i) !== -1).length
};
```

## 2000. 反转单词前缀

第一种解法：暴力法

这种思路就是用一下数组的 `reverse` API，思路非常简单粗暴

时间复杂度超过 11.57% 提交，空间复杂度超过 89.26% 提交

```js
var reversePrefix = function(word, ch) {
  if (!word.includes(ch)) return word;
  const i = word.indexOf(ch)
  const firstHalf = word.slice(0, i + 1), secondHalf = word.slice(i + 1, word.length)
  return firstHalf.split('').reverse().join('').concat(secondHalf)
};
```

第二种解法：双指针法

这种思路也很简单，但需要注意不能直接在字符串上进行双指针操作，而要转换成数组再对调位置

时间复杂度超过 21.49% 提交，空间复杂度超过 60.33% 提交

```js
var reversePrefix = function(word, ch) {
  if (!word.includes(ch)) return word;
  const index = word.indexOf(ch), arr = word.split('')
  let i = 0, j = index;
  while (i < j) {
    [arr[i], arr[j]] = [arr[j], arr[i]]
    i++
    j--
  }
  return arr.join('')
};
```

## 2085. 统计出现过一次的公共字符串

第一种解法：哈希表法

我先写上超级无敌丑的哈希表解法吧，就是连着三个哈希表。。。。我是笨比

这个思路就是筛选出来后脑袋短路了又来一个哈希表再筛选，完全没想到只要遍历之前两个任一个哈希表就 ok 的思路，因此时间复杂度和空间复杂度都难看到家了

时间复杂度超过 22.22% 提交，空间复杂度超过 5.55% 提交

```js
var countWords = function(words1, words2) {
  const map1 = new Map(), map2 = new Map()
  for (let i of words1) {
    if (map1.has(i)) map1.set(i, map1.get(i) + 1);
    else map1.set(i, 1)
  }
  for (let i of words2) {
    if (map2.has(i)) map1.set(i, map2.get(i) + 1);
    else map2.set(i, 1)
  }
  const arr1 = Array.from(map1).filter(i => i[1] === 1).map(j => j[0])
  const arr2 = Array.from(map2).filter(i => i[1] === 1).map(j => j[0])
  const temp = [...arr1, ...arr2]
  const map3 = new Map()
  for (let i of temp) {
    if (map3.has(i)) map3.set(i, map3.get(i) + 1);
    else map3.set(i, 1)
  }
  return Array.from(map3).filter(i => i[1] === 2).length
};
```

下面这种就是正常的哈希表解法了。。。一对比就知道上面的多 sb 了是吧

时间复杂度超过 92.59% 提交，空间复杂度超过 79.63% 提交

```js
var countWords = function(words1, words2) {
  const map1 = new Map(), map2 = new Map()
  for (let i of words1) {
    if (map1.has(i)) map1.set(i, map1.get(i) + 1);
    else map1.set(i, 1)
  }
  for (let i of words2) {
    if (map2.has(i)) map1.set(i, map2.get(i) + 1);
    else map2.set(i, 1)
  }
  // 以上都是完全一样的
  let count = 0
  map1.forEach((value, key) => {
    if (map2.has(key) && map2.get(key) === 1 && value === 1) count++
  })
  return count
};
```

## 2114. 句子中的最多单词数

第一种解法：暴力法

这种思路是自己想的，就直接用 `split` API 然后遍历一遍

时间复杂度超过 81.89% 提交，空间复杂度超过 47.24% 提交

```js
var mostWordsFound = function(sentences) {
  const len = []
  for (let i of sentences) {
    len.push(i.split(" ").length)
  }
  return Math.max(...len)
};
```

第二种解法：数空格法

这种也是自己想出来的，不先将字符串拆成数组，而是直接遍历字符串数空格数量，单词的数量永远比空格数量多一

时间复杂度超过 81.89% 提交，空间复杂度超过 90.55% 提交

```js
var mostWordsFound = function(sentences) {
  const len = []
  for (let i of sentences) {
    let count = 0
    for (let j = 0; j < i.length; j++) {
      if (i[j] === " ") count++
    }
    len.push(count + 1)
  }
  return Math.max(...len)
};
```

第三种解法：一行正则法

这种是题解[这位大神](https://leetcode.cn/problems/maximum-number-of-words-found-in-sentences/solution/zheng-ze-a-zheng-ze-by-lopo12123-pytr/)的解法，我确实想到正则的思路，但也确实不会。。。

时间复杂度超过 92.13% 提交，空间复杂度超过 74.80% 提交

```js
var mostWordsFound = function(sentences) {
  return Math.max(...sentences.map((i) => (i.match(/[ ]/g)?.length ?? 0) + 1))
};
```

## 2124. 检查是否所有 A 都在 B 之前

第一种解法：暴力法

这种思路就是直接遍历配上两个数组，最后分别取 a 的最大值和 b 的最小值比较

时间复杂度超过 93.22% 提交，空间复杂度超过 10.17% 提交

```js
var checkString = function(s) {
  const arra = [], arrb = []
  for (let i = 0; i < s.length; i++) {
    if (s[i] === 'a') arra.push(i);
    else if (s[i] === 'b') arrb.push(i)
  }
  if (Math.max(...arra) < Math.min(...arrb)) return true;
  else return false;
};
```

另这种思路不用数组辅助还可以用一个变量来做

时间复杂度超过 100.00% 提交，空间复杂度超过 30.51% 提交

```js
var checkString = function(s) {
  let maxa = Number.MIN_SAFE_INTEGER, minb = Number.MAX_SAFE_INTEGER
  for (let i = 0; i < s.length; i++) {
    if (s[i] === 'a' && i > maxa) maxa = i; 
    else if (s[i] === 'b' && i < minb) minb = i;
  }
  return maxa < minb
};
```

第二种解法：indexOf + lastIndexOf API

这种就非常直接，上 API 就完事了，另外还需要注意一下字符串中只有 a 或只有 b 的情况就 OK

时间复杂度超过 100.00% 提交，空间复杂度超过 35.59% 提交

```js
var checkString = function(s) {
  let maxa = s.lastIndexOf('a'), minb = s.indexOf('b')
  if ((maxa === -1 && minb > -1) || (maxa > -1 && minb === -1)) return true;
  else return maxa < minb;
};
```

第三种解法：脑筋急转弯法

这种思路是官方题解的思路，其实就是将题目翻译为是否包含子字符串 ba ，然后直接上 includes API 就完事了

时间复杂度超过 100.00% 提交，空间复杂度超过 100.00% 提交，时间复杂度为 O(n)，空间复杂度为 O(1)

```js
var checkString = function(s) {
  return s.includes('ba') ? false : true
};
```

## 2185. 统计包含给定前缀的字符串

第一种解法：暴力法

这种思路就是用一个 `slice` API 再遍历一次就 OK

时间复杂度超过 47.69% 提交，空间复杂度超过 12.24% 提交

```js
var prefixCount = function(words, pref) {
  const len = pref.length
  let count = 0
  for (let i of words) {
    if (i.slice(0, len) === pref) count++
  }
  return count
};
```

第二种解法：startsWith API 法

这种思路跟第一种完全一样，就是换一个 API而已，不过可能稍微注意是 `startsWith` 而不是 `startWith` 否则会错哦

时间复杂度超过 47.69% 提交，空间复杂度超过 72.16% 提交

```js
var prefixCount = function(words, pref) {
  let count = 0
  for (let i of words) {
    if (i.startsWith(pref)) count++
  }
  return count
};
```

## 2278. 字母在字符串中的百分比

第一种解法：暴力法

这种是我自己的思路，就是遍历一遍然后直接得出结果，需要注意一下为了求百分比需要多除一次 100 哦

时间复杂度超过 85.71% 提交，空间复杂度超过 40.00% 提交

```js
var percentageLetter = function(s, letter) {
  const len = s.length
  let count = 0
  for (let i = 0; i < len; i++) {
    if (letter === s[i]) count++
  }
  return Math.floor(count / len * 100)
};
```

第二种解法：转数组用 reduce API 法

这种也是自己想出来的，不过是想到之前写过在一种类似的解法，也就是数组简单组 #1295 的第二种解法，回看了一下然后就用到这里了，个人感觉也挺好用

时间复杂度超过 85.71% 提交，空间复杂度超过 62.86% 提交

```js
var percentageLetter = function(s, letter) {
  const arr = s.split(''), len = s.length
  let count = arr.reduce((sum, cur) => (cur === letter) ? sum + 1 : sum, 0)
  return Math.floor(count / len * 100)
};
```

第三种解法：`replaceAll` API 法

这种是看[这位大神的题解](https://leetcode.cn/problems/percentage-of-letter-in-string/solution/by-determined-vaughan3st-qipo/)才知道原来还可以这么做，其实就是将原单词中和 letter 相同的字母删除，然后做一个减法就可以得出答案，确实很妙，我也是第一次实际使用 `replaceAll` 这个 API

时间复杂度超过 18.57% 提交，空间复杂度超过 85.71% 提交

```js
var percentageLetter = function(s, letter) {
  const str = s.replaceAll(letter, '')
  return Math.floor((s.length - str.length) / s.length * 100)
};
```

## 2351. 第一次出现两次的字母

第一种解法：暴力法

用一个变量配合嵌套 for 循环，毫无技巧可言，就是这么暴力

时间复杂度超过 94.64% 提交，空间复杂度超过 27.68% 提交

```js
var repeatedCharacter = function(s) {
  let num = Number.MAX_SAFE_INTEGER;
  for (let i = 0; i < s.length - 1; i++) {
    for (let j = i + 1; j < s.length; j++) {
      if (s[j] === s[i]) num = Math.min(j, num);
    }
  }
  return s[num]
};
```

第二种解法：indexOf 解法

我尝试过用 indexOf 来解这道题，但是没有想明白，[这位大神的思路](https://leetcode.cn/problems/first-letter-to-appear-twice/solution/by-dong-z4-gkmw/)就很巧妙，膜拜一下

就是利用 `indexOf` 总是返回此元素的第一个索引，如果遍历时某个元素的索引与这个位置上此元素在整个字符串中的第一个索引不相等，说明这个元素就是第一个重复出现的字母

比如 `"abccb"` 这个字符串，遍历时第一个元素的 `i = 0`，`s.indexOf(a) = 0`，同理第三个元素的 `i = 2`，`s.indexOf(c) = 2`，第四个元素的 `i = 3`， `s.indexOf(c) = 2`，因此第四个元素 `c` 就是一个出现两次的字母

时间复杂度超过 84.82% 提交，空间复杂度超过 95.54% 提交

```js
var repeatedCharacter = function(s) {
  for (let i = 0; i < s.length; i++) {
    if (s.indexOf(s[i]) !== i) return s[i];
  }
};
```

第三种解法：Set 解法

这种就是在遍历时首先把元素都放到 Set 结构里面，如果中间发现 Set 里面已经存在某个元素，也就相当于这个元素出现了第二次，直接返回这个元素就可以了

时间复杂度超过 62.50% 提交，空间复杂度超过 75.89% 提交

```js
var repeatedCharacter = function(s) {
  const set = new Set()
  for (let i of s) {
    if (set.has(i)) return i;
    set.add(i)
  }
}
```

同理还有一种相同思路的另一种写法

时间复杂度超过 94.42% 提交，空间复杂度超过 22.21% 提交

```js
var repeatedCharacter = function(s) {
  const obj = {}
  for (let i of s) {
    if (obj[i]) return i;
    obj[i] = 1
  }
}
```

第四种解法：哈希表法（待填坑）

这种是[官方题解](https://leetcode.cn/problems/first-letter-to-appear-twice/solution/di-yi-ge-chu-xian-liang-ci-de-zi-mu-by-l-oqu1/)提到的

## 2496. 数组中字符串的最大值

第一种解法：遍历法

这种思路我一开始用了 `parseInt` API，但只能过去 60 / 64 的测试用例，比如 `3giko` 的这种不会被当作 5 而会转成 3，就不对了，所以就用 `Number()` 来做

另如果不用一个变量 `max` 来计算结果，也可以用一个数组最后再求最大值，这里就不赘述了

时间复杂度超过 96.10% 提交，空间复杂度超过 19.48% 提交

```js
var maximumValue = function(strs) {
  let max = 0
  for (let i of strs) {
    if (isNaN(Number(i))) max = Math.max(i.length, max);
    else max = Math.max(parseInt(i, 10), max);
  }
  return max
};
```

第二种解法：正则法

本来想了一个利用小写字母 a - z 的 ASCII 码范围是 [97, 122] 配合 `charCodeAt()` API 来解的思路，但是没写出来，翻到字符串中的 `match()` API，索性就用正则来做好了。。。。

时间复杂度超过 65.58% 提交，空间复杂度超过 12.34% 提交

```js
var maximumValue = function(strs) {
  let max = 0, regex = /[a-z]/g
  for (let str of strs) {
    let temp = str.match(regex)
    if (temp && temp.length > 0) { // 注意 temp 可能为 null
      max = Math.max(max, str.length)
    } else {
      max = Math.max(max, Number(str))
    }
  }
  return max
};
```

