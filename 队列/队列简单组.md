## 225. 用队列实现栈

第一种解法：用一个队列

这是进阶要求，而且感觉也比较清晰易懂，这种方法唯一需要想一下的就是 `pop` 方法的逻辑

由于队列是先进先出结构，栈是先进后出机构，如果要从栈结构 `pop` 取出元素就需要将队列结构最后一个 `push` 进的元素取出来

为此可以脑补一个循环，把队列前面的每个元素分别 `shift` 出来再 `push` 回去，直到队列最前面的元素就是原来队列最后的那个，最后 `shift` 出来就可以了

时间复杂度超过 33.98% 提交，空间复杂度超过 34.85% 提交

```js
var MyStack = function() {
  this.q = []
};

MyStack.prototype.push = function(x) {
  this.q.push(x)
};

MyStack.prototype.pop = function() {
  let len = this.q.length
  while (len > 1) {
    this.q.push(this.q.shift())
    len--
  }
  return this.q.shift()
};

MyStack.prototype.top = function() {
  const x = this.q.pop()
  this.q.push(x)
  return x
};

MyStack.prototype.empty = function() {
  return this.q.length === 0
};
```

## 232. 用栈实现队列



## 933. 最近的请求次数

第一种解法：队列

这道题看着题目描述那么多字感觉还挺唬人的，实际翻译一下就是用一个队列先进先出特性来解决

在这个队列中存放每次发生请求的时间 `t`，由于保证每次调用 `ping` 的 `t` 值都是递增的，当每次收到请求时，一方面将新的请求时间 `t` 推入队列，另一方面从队首不断弹出早于 `t - 3000` 的时间，最后返回队列长度就可以了

时间复杂度超过 33.68% 提交，空间复杂度超过 39.82% 提交，时间复杂度是均摊 O(1)，每个元素至多入队出队各一次，空间复杂度是 O(L)，L 是队列的最大元素个数

```js
var RecentCounter = function() {
  this.q = []
}

RecentCounter.prototype.ping = function(t) {
  this.q.push(t)
  while (this.q[0] < t - 3000) {
    this.q.shift()
  }
  return this.q.length
}
```

