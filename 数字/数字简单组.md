## 202. 快乐数

这道题我个人觉得跟题目完全无关，在没看懂规律之前一点都不快乐，我想了一会想到递归的思路但感觉会比较麻烦不太对劲，直接就去看题解了

这里的套路个人感觉[官方的题解](https://leetcode.cn/problems/happy-number/solution/kuai-le-shu-by-leetcode-solution/)分析的最透彻，不管使用哈希表还是快慢指针解题的前提得是先分析出题目的套路，把它的原题描述转化成一个规律，也就是不断重复求每个数字每个位置上的数字的平方和会出现哪几种情况

* 第一种：最终会得到 1
* 第二种：最终会进入循环
* 第三种：值会越来越大，最后接近无穷大（实际是不会发生的，但也得看懂分析才知道）

在明白这几种情况的前提后，剩下的解法确实就是简单的难度了不假

第一种：快慢指针解法

这种解法和链表简单组 #141 是完全一样的套路，具体讲解可以参考拉神讲[链表双指针的这篇](https://labuladong.gitee.io/algo/1/4/)，保证清晰易懂

时间复杂度超过 75.94% 提交，空间复杂度超过 23.71% 提交

```js
var isHappy = function(n) {
  // 首先是求每个数字每个位置上的数字的平方和的函数，这种借鉴来的写法个人觉得有点秀，用到 ES6 的求幂运算符和数组 reduce 方法
  const getNext = (n) => {
    return n
    	.toString()
    	.split("")
    	.map((i) => i ** 2)
    	.reduce((prev, curr) => prev + curr)
  }
  // 这部分就完全是判断是否成环的思路，跟链表是一模一样的
  let slow = n, fast = getNext(n)
  while (fast !== slow && fast !== 1) { // 这里只判断快慢指针是否相等也能过去
    slow = getNext(slow)
    fast = getNext(getNext(fast))
  }
  return fast === 1
}
```

第二种：哈希表解法（待填坑）

## 231. 2的幂

首先因为刷这道题之前我自己是先刷的下面 #326 3的幂这道题，所以会先把几种解法直接搬过来，具体解释就不再重复了

第一种解法：暴力试除法

时间复杂度超过 98.11% 提交，空间复杂度超过 87.89% 提交

```js
var isPowerOfTwo = function(n) {
  if (n <= 0) return false;
  while (n % 2 === 0) n /= 2;
  return n === 1
};
```

第二种解法：从 1 往上乘解法

时间复杂度超过 85.50% 提交，空间复杂度超过 81.65% 提交

```js
var isPowerOfTwo = function(n) {
  if (n <= 0) return false;
  if (n === 1) return true;
  let i = 1
  while (i < n) {
    let temp = i * 2
    if (temp === n) return true;
    else if (temp > n) return false;
    i = temp
  }
};
```

第三种解法：递归解法

时间复杂度超过 94.63% 提交，空间复杂度超过 93.91% 提交

```js
var isPowerOfTwo = function(n) {
  if (n <= 0) return false;
  if (n === 1) return true;
  if (n % 2 === 0) return isPowerOfTwo(n / 2);
  else return false;
};
```

第四种解法：判断是否为最大 2 的幂的约数解法

在题目给定的 32 位有符号整数的范围内，最大的 2 的幂为 2³⁰ = 1073741824，因此只需要判断 n 是否是 2³⁰ 的约数即可

时间复杂度超过 53.08% 提交，空间复杂度超过 50.55% 提交，时间复杂度是 O(1)，空间复杂度是 O(1)

```js
var isPowerOfTwo = function(n) {
  return n > 0 && 1073741824 % n === 0
};
```

在[官方题解](https://leetcode.cn/problems/power-of-two/solution/2de-mi-by-leetcode-solution-rny3/)中这种解法还有一种写法

时间复杂度超过 53.08% 提交，空间复杂度超过 51.13% 提交

```js
var isPowerOfTwo = function(n) {
  const BIG = 1 << 30
  return n > 0 && BIG % n === 0
}
```

第五种解法：转二进制解法

时间复杂度超过 72.30% 提交，空间复杂度超过 51.20% 提交

```js
var isPowerOfTwo = function(n) {
  const str = n.toString(2)
  if (str[0] !== '1') return false;
  for (let i = 1; i < str.length; i++) {
    if (str[i] !== '0') return false;
  }
  return true
};
```

第六种解法：`n & (n - 1)` 解法

这个思路是[拉神讲位操作](https://labuladong.gitee.io/algo/4/32/114/)这篇文章中的提到的，`n & (n - 1)` 的作用是消除数字 `n` 的二进制表示中的最后一个 1

其核心逻辑就是，`n - 1` 一定可以消除最后一个 1，同时把其后的 0 都变成 1，这样再和 `n` 做一次 `&` 运算，就可以仅仅把最后一个 1 变成 0 了

<img src="../assets/22112101.png" alt="22112101" style="zoom: 67%;" />

在这道题中，一个数如果是 2 的指数，那么它的二进制表示一定只含有一个 1

```js
2^0 = 1 = 0b0001
2^1 = 2 = 0b0010
2^2 = 4 = 0b0100
```

时间复杂度超过 34.66% 提交，空间复杂度超过 85.35% 提交，时间复杂度是 O(1)，空间复杂度是 O(1)

```js
var isPowerOfTwo = function(n) {
  return n > 0 && (n & (n - 1)) === 0
};
```

第七种解法：`n & (-n)` 解法

这种也是官方题解中提到的，但我个人感觉已经超出我的脑容量了就不研究了，会第六种对我个人来说暂时应该已经够用了，因此就放在这用来展示还可以这样做

时间复杂度超过 53.08% 提交，空间复杂度超过 92.68% 提交，时间复杂度是 O(1)，空间复杂度是 O(1)

```js
var isPowerOfTwo = function(n) {
  return n > 0 && (n & -n) === n
};
```

## 326. 3的幂

第一种解法：暴力试除法

试除法这个名字我确实第一次见到，这种思路就是拿这个数不断取 3 的余数，直到余数不再为 0 为止即不是 3 的倍数，判断剩下的数是否等于 1 即 3 的 0 次方

时间复杂度超过 94.35% 提交，空间复杂度超过 50.65% 提交

```js
var isPowerOfThree = function(n) {
  if (n <= 0) return false;
  while (n % 3 === 0) n /= 3;
  return n === 1
}
```

第二种解法：从 1 往上乘解法

这个思路是借鉴这位[大神](https://leetcode.cn/problems/power-of-three/solution/jsxiao-xiao-whilexun-huan-by-yao-n1-nypo/)的解法，我想到这种从小往大的思路但写不明白，这位大神就做到了

时间复杂度超过 49.02% 提交，空间复杂度超过 83.04% 提交

```js
var isPowerOfThree = function(n) {
  if (n <= 0) return false;
  if (n === 1) return true; // 3 的 0 次方
  let i = 1
  while (i < n) {
    let temp = i * 3
    if (temp === n) return true;
    else if (temp > n) return false;
    i = temp // 这个 while 循环的条件和这里赋值我就没想到，是我太笨。。。
  }
}
```

第三种解法：递归解法

递归的思路也是借鉴的另一位[大神](https://leetcode.cn/problems/power-of-three/solution/326-3de-mu-cc-di-gui-by-lzcnoi-masm/)，虽然是 C 语言写的，但写法完全跟 JS 一样，重点应该是递归的思想，感觉也可以理解为第一种解法的另一种写法，也挺巧妙的是吧

时间复杂度超过 62.17% 提交，空间复杂度超过 19.78% 提交

```js
var isPowerOfThree = function(n) {
  if (n <= 0) return false;
  if (n === 1) return true;
  if (n % 3 === 0) return isPowerOfThree(n / 3);
  else return false;
}
```

第四种解法：判断是否为最大 3 的幂的约数解法

题目进阶要求是不用循环或递归，前面的几种都满足不了，于是就有这种我想到死也想不到的取巧思路。。。

由于 n <= 2³¹ - 1，因此在此限制下最大 3 的幂为 3¹⁹ = 1162261467，如果 n 为 3 的幂的话，那么必然满足 n * 3ᵏ = 1162261467，即 n 与 1162261467 存在倍数关系，因此只需要判断 n 是否是 1162261467 的约数即可

此思路只为了展示居然还可以这么解。。。我个人还是乖乖用上面三种方法好了，如果追问进阶要求我会直接放弃，能力实在不够哇。。。

时间复杂度超过 41.63% 提交，空间复杂度超过 70.43% 提交

```js
var isPowerOfThree = function(n) {
  return n > 0 && 1162261467 % n === 0
}
```

第五种解法：转三进制解法

这种思路是借鉴这位[大神](https://leetcode.cn/problems/power-of-three/solution/javascriptban-jie-ti-si-lu-by-ityou-o-fiwt/)的，实话实话，目前连二进制还没完全搞明白，这种就也是放在这以展示我超原来这样也可以，实际我个人 99.99% 情况宁可放弃也不用这种解法，一是这里也得循环，二是脑容量实在有限。。。

时间复杂度超过 22.72% 提交，空间复杂度超过 15.54% 提交

```js
var isPowerOfThree = function(n) {
  // 转化为三进制，判断是否只有一个前导 0 即可
  const str = n.toString(3)
  if (str[0] !== '1') return false;
  for (let i = 1; i < str.length; i++) {
    if (str[i] !== '0') return false;
  }
  return true
}
```

