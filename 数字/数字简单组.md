## 202. 快乐数

这道题我个人觉得跟题目完全无关，在没看懂规律之前一点都不快乐，我想了一会想到递归的思路但感觉会比较麻烦不太对劲，直接就去看题解了

这里的套路个人感觉[官方的题解](https://leetcode.cn/problems/happy-number/solution/kuai-le-shu-by-leetcode-solution/)分析的最透彻，不管使用哈希表还是快慢指针解题的前提得是先分析出题目的套路，把它的原题描述转化成一个规律，也就是不断重复求每个数字每个位置上的数字的平方和会出现哪几种情况

* 第一种：最终会得到 1
* 第二种：最终会进入循环
* 第三种：值会越来越大，最后接近无穷大（实际是不会发生的，但也得看懂分析才知道）

在明白这几种情况的前提后，剩下的解法确实就是简单的难度了不假

第一种：快慢指针解法

这种解法和链表简单组 #141 是完全一样的套路，具体讲解可以参考拉神讲[链表双指针的这篇](https://labuladong.gitee.io/algo/1/4/)，保证清晰易懂

时间复杂度超过 75.94% 提交，空间复杂度超过 23.71% 提交

```js
var isHappy = function(n) {
  // 首先是求每个数字每个位置上的数字的平方和的函数，这种借鉴来的写法个人觉得有点秀，用到 ES6 的求幂运算符和数组 reduce 方法
  const getNext = (n) => {
    return n
    	.toString()
    	.split("")
    	.map((i) => i ** 2)
    	.reduce((prev, curr) => prev + curr)
  }
  // 这部分就完全是判断是否成环的思路，跟链表是一模一样的
  let slow = n, fast = getNext(n)
  while (fast !== slow && fast !== 1) { // 这里只判断快慢指针是否相等也能过去
    slow = getNext(slow)
    fast = getNext(getNext(fast))
  }
  return fast === 1
}
```

第二种：哈希表解法（待填坑）

## 326. 3的幂

第一种解法：暴力试除法

试除法这个名字我确实第一次见到，这种思路就是拿这个数不断取 3 的余数，直到余数不再为 0 为止即不是 3 的倍数，判断剩下的数是否等于 1 即 3 的 0 次方

时间复杂度超过 94.35% 提交，空间复杂度超过 50.65% 提交

```js
var isPowerOfThree = function(n) {
  if (n <= 0) return false;
  while (n % 3 === 0) n /= 3;
  return n === 1
}
```

第二种解法：从 1 往上乘解法

这个思路是借鉴这位[大神](https://leetcode.cn/problems/power-of-three/solution/jsxiao-xiao-whilexun-huan-by-yao-n1-nypo/)的解法，我想到这种从小往大的思路但写不明白，这位大神就做到了

时间复杂度超过 49.02% 提交，空间复杂度超过 83.04% 提交

```js
var isPowerOfThree = function(n) {
  if (n <= 0) return false;
  if (n === 1) return true; // 3 的 0 次方
  let i = 1
  while (i < n) {
    let temp = i * 3
    if (temp === n) return true;
    else if (temp > n) return false;
    i = temp // 这个 while 循环的条件和这里赋值我就没想到，是我太笨。。。
  }
}
```

第三种解法：递归解法

递归的思路也是借鉴的另一位[大神](https://leetcode.cn/problems/power-of-three/solution/326-3de-mu-cc-di-gui-by-lzcnoi-masm/)，虽然是 C 语言写的，但写法完全跟 JS 一样，重点应该是递归的思想，感觉也可以理解为第一种解法的另一种写法，也挺巧妙的是吧

时间复杂度超过 62.17% 提交，空间复杂度超过 19.78% 提交

```js
var isPowerOfThree = function(n) {
  if (n <= 0) return false;
  if (n === 1) return true;
  if (n % 3 === 0) return isPowerOfThree(n / 3);
  else return false;
}
```

第四种解法：判断是否为最大 3 的幂的约数解法

题目进阶要求是不用循环或递归，前面的几种都满足不了，于是就有这种我想到死也想不到的取巧思路。。。

由于 n <= 2³¹ - 1，因此在此限制下最大 3 的幂为 3¹⁹ = 1162261467，如果 n 为 3 的幂的话，那么必然满足 n * 3ᵏ = 1162261467，即 n 与 1162261467 存在倍数关系，因此只需要判断 n 是否是 1162261467 的约数即可

此思路只为了展示居然还可以这么解。。。我个人还是乖乖用上面三种方法好了，如果追问进阶要求我会直接放弃，能力实在不够哇。。。

时间复杂度超过 41.63% 提交，空间复杂度超过 70.43% 提交

```js
var isPowerOfThree = function(n) {
  return n > 0 && 1162261467 % n === 0
}
```

第五种解法：转三进制解法

这种思路是借鉴这位[大神](https://leetcode.cn/problems/power-of-three/solution/javascriptban-jie-ti-si-lu-by-ityou-o-fiwt/)的，实话实话，目前连二进制还没完全搞明白，这种就也是放在这以展示我超原来这样也可以，实际我个人 99.99% 情况宁可放弃也不用这种解法，一是这里也得循环，二是脑容量实在有限。。。

时间复杂度超过 22.72% 提交，空间复杂度超过 15.54% 提交

```js
var isPowerOfThree = function(n) {
  // 转化为三进制，判断是否只有一个前导 0 即可
  const str = n.toString(3)
  if (str[0] !== '1') return false;
  for (let i = 1; i < str.length; i++) {
    if (str[i] !== '0') return false;
  }
  return true
}
```

