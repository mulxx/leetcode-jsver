## 46. 全排列

这道题感觉是回溯算法的入门题，也是拉神讲回溯框架的第一题，我也实际在很多经典题精华题库里看到过，而且又是一道中等难度的题，因此个人推测会是面试中的热门题之一，看拉神的讲解洋洋洒洒那么多，刚看可能会打怵，但硬啃下来感觉肯定不亏，不管是作为回溯入门还是面试备考应该都算超值

为了回顾拉神讲解，也为了给回溯系列做个铺垫，还是把几个重点概念先搬过来备着

* 回溯算法和 DFS 算法非常类似，本质上就是一种暴力穷举算法，它俩的细微差别是：回溯算法是在遍历**「路径（树枝）」**，DFS 算法是在遍历**「节点」**
* 回溯算法框架实际上就是一个决策树的遍历过程，站在回溯树的一个节点上，只需要思考 3 个问题
  * 1、路径：也就是已经做出的选择
  * 2、选择列表：也就是当前可以做的选择
  * 3、结束条件：也就是到达决策树底层，无法再做选择的条件
* 回溯算法框架
  * 其核心就是 **for 循环里面的递归**，在递归之前**「做选择」**，在递归之后**「撤销选择」**

```js
const result = [] // 存储结果
const backtrack = (路径, 选择列表) => {
  if (满足结束条件) {
    result.add(路径)
    return
  }
  for (选择 in 选择列表) {
    做选择
    backtrack(路径, 选择列表)
    撤销选择
  }
}
```

* 各种搜索问题其实都是一棵树的遍历问题，如多叉树的回溯遍历框架
  * 注：在 DFS 多叉树遍历框架中，前序和后序位置应该在 for 循环外面，而回溯算法在 for 循环里面

```js
var backtrack = function(root) {
  for (let child of root.children) {
    // 前序位置需要的操作
    backtrack(child)
    // 后序位置需要的操作
  }
}
```

第一种解法：拉神版回溯

根据拉神的讲解，第一步要脑补出或者画出这道题的「回溯树」或者「决策树」，只要从根遍历这棵树，记录路径上的数字，其实就是所有的全排列，称为「决策树」的原因是在每个节点上都在做决策

这道题中的三个概念

* 路径：在决策树上的一个节点，比如 [2]（即已经做出的选择）
* 选择列表：[1, 3]（即当前可以做的选择）
* 结束条件：遍历到树的底层叶子节点，或选择列表为空时（即到达决策树底层，无法再做选择的条件）

定义的 `backtrack` 函数其实就像一个指针，在这棵树上游走，同时要正确维护每个节点的属性，每当走到树的底层叶子节点，其「路径」就是一个全排列

「路径」和「选择」是每个节点的属性，函数在树上游走要正确维护节点的属性，那么就要在这前序和后序两个特殊时间点操作，在前序位置递归之前做选择，在后序位置递归之后撤销选择，就能正确得到每个节点的选择列表和路径

```js
for (选择 in 选择列表) {
  将该选择从「选择列表」移除
  路径.add(选择)
  // 以上为前序位置递归之前，做选择
  backtrack(路径, 选择列表)
  // 以下为后序位置递归之后，撤销选择
  路径.remove(选择)
  将该选择再加入「选择列表」
}
```

以下解法稍有一些变通，没有显式记录「选择列表」，而是通过 `used` 数组排除已经存在 `path` 中的元素，从而推导出当前的选择列表

这种解法不是最高效的，有的解法连 `used` 数组都不使用，通过交换元素达到目的，但是那种解法稍微难理解一些

时间复杂度超过 96.99% 提交，空间复杂度超过 75.56% 提交，不管怎么优化，回溯框架的时间复杂度都不可能低于 O(N!)，因为穷举整棵决策树是无法避免的

这也是回溯算法的一个特点，不像动态规划存在重叠子问题可以优化，回溯算法就是纯暴力穷举，复杂度一般都很高

```js
var permute = function(nums) {
  const res = [] // 最后返回的结果
  const path = [] // 路径：记录在 path 中
  const used = new Array(nums.length) // 「路径」中的元素会被标记为 true，避免重复使用
  
  // 选择列表：nums 中不存在于 path 的那些元素（变通为 used[i] 为 false）
  const backtrack = (path) => {
    // 结束条件：nums 中的元素全都在 path 中出现
    if (path.length === nums.length) {
      return res.push(path.slice())
    }
    for (let i = 0; i < nums.length; i++) {
      if (used[i] === true) continue; // nums[i] 已经在 path 中，跳过
      path.push(nums[i]) // 做选择
      used[i] = true
      backtrack(path) // 进入下一层决策树
      path.pop() // 撤销选择
      used[i] = false
    }
  }
  
  backtrack(path)
  return res
}
```

