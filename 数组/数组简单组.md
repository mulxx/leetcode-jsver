### 1. 两数之和

* 暴力解，遍历两次数组，时间复杂度应该在 O(n²) 以上
* 时间复杂度超过 24.96% 提交，空间复杂度超过 67.71% 提交（可能是最无脑的解法，就是不太好看）

```js
var twoSum = function(nums, target) {
  let res = []
  for (let i = 0; i < nums.length; i++) {
    // 这里初始化 j 的时候需要注意不能让 j = 1，否则是过不去的，只能通过 38 / 57 的测试用例
    for (let j = i + 1; j < nums.length; j++) {
      if (nums[i] + nums[j] === target) {
        res.push(i)
        res.push(j)
      }
    }
  }
  return res
};
```

* HashTable 版进阶（待填坑）

### 26. 删除有序数组中的重复项

* 双指针解法（拉神说的**只要数组有序，就应该想到双指针技巧**），因为需要「原地」删除，所以考虑用快慢指针来解
* 我第一次做这道题的时候就没好好审题，违背了「不要使用额外的空间，必须在原地修改输入数组」，所以要细心好吧
* 这里可以参考拉神的 GIF 图，理解起来就很直观
* 时间复杂度超过 48.08% 提交，空间复杂度超过 50.40% 提交

```js
var removeDuplicates = function(nums) {
  // 提示中给出了 nums.length >= 1，这里特殊处理一下
  if (nums.length === 1) return 1;
  let slow = 0, fast = 0
  while (fast < nums.length) {
    if (nums[fast] !== nums[slow]) {
      // 这两行需要注意顺序不能反过来，否则只能通过 6 / 361 的测试用例，想的时候可以脑补一下拉神的动图是吧
      slow++
      nums[slow] = nums[fast]
    }
    fast++
  }
  // 这里 nums[0 ... slow] 是最后的去重结果,数组长度为 slow + 1
  return slow + 1
}
```

* 但有意思的一个地方我在自己写的时候把 fast 指针初始化为 1 了，其他地方完全不变，也顺利通过了，甚至时间复杂度还超过 79.21% 提交，比 48.04% 还好（黑人问号脸）？
* 这个问题我的理解应该是这样，因为一开始就将 fast 指针设为 1，可以少跑一次循环，因为当 slow = fast = 0 时，两个数字肯定是一样的，在自己打 log 测试时也佐证了我的想法

### 27. 移除元素

* 这道题跟 26 题有些像，还是原地操作数组，还可以用快慢指针，但这里题目没说是有序数组哈
* 时间复杂度超过 71.80% 提交，空间复杂度超过 51.39% 提交

```js
var removeElement = function(nums, val) {
  // 提示中给出了 nums.length >= 0
  if (nums.length === 0) return 0;
  let slow = 0, fast = 0
  while (fast < nums.length) {
    if (nums[fast] !== val) {
      // 这两行注意顺序跟 26 题反过来了，稍微脑筋急转弯一下如果是连着做这两道题是吧
      nums[slow] = nums[fast]
      slow++
    }
    fast++
  }
  // 这里 nums[0 ... slow - 1] 是最后移除完 target 的结果，因此数组长度是 slow - 1 + 1 = slow
  // return slow 还是 slow + 1 这里我感觉有点绕，想了半天。。。
  return slow
}
```

* 这道题把 fast 初始化为 1 就不行了，因为直接跳过判断第一个元素了那肯定不对啊

### 35. 搜索插入位置

* 题目要求说必须使用时间复杂度为 `O(log n)` 的算法，按理说应该直接想到二分法，但是我看提示中 nums 为 **无重复元素** 的 **升序** 排列数组，一看「数组」「有序」，我的第一次尝试居然就用了快慢指针。。。
* 时间复杂度超过 85.41% 提交，空间复杂度超过 48.33% 提交

```js
var searchInsert = function(nums, target) {
  let slow = 0, fast = 0
  while (fast < nums.length) {
    if (nums[fast] === target) {
      return fast
    } else if (nums[fast] > target) {
      return slow
    } else if (nums[fast] < target) {
      slow = fast + 1
    }
    fast++
  }
  return slow
}
```

* 二分法这题参考 angela 大神，应该可以分为左闭右闭，左闭右开和左闭右开简化版，左闭右开就暂时留坑。。。
* 我的无脑版左闭右闭解法（框架直接套拉神的二分框架）
* 时间复杂度超过 42.82% 提交，空间复杂度超过 60.46% 提交

```js
var searchInsert = function(nums, target) {
  let left = 0, right = nums.length - 1
  while (left <= right) {
    // 这里这样写是有说法的，你看无脑取 mid 就直接 Math.floor((left + right) / 2) 对吧
    // 但是不管是 JS 语言或其他语言在计算 mid 时都需要防止溢出，所以就优化为 Math.floor(left + (right - left) / 2)，避免 left 和 right 太大直接相加溢出，撅撅了
    // 再因为 JS 中 >> 移位运算比除法操作性能好很多，所以就最终优化为 left + ((right - left) >> 1)，这种还不用套一层 Math.floor 处理
    let mid = left + ((right - left) >> 1)
    if (nums[mid] === target) {
      return mid
    } else if (nums[mid] < target) {
      left = mid + 1 // 这里 < 和 > 下面改变边界要仔细想一下不要混淆，我第一次就糊涂了
    } else if (nums[mid] > target) {
      right = mid - 1
    }
  }
  return left
}
```

### 121. 买卖股票的最佳时机

* 如果翻译一下这个股票啥的其实就是求数组中最大值和最小值的差，我的第一个想法就是遍历两次配合快慢指针，没错我又只能想到快慢指针。。。
* 但这种做法会超出时间限制，只能通过 206 / 211 的测试用例，所以时间复杂度 O(n²) 以上，也通过不了

```js
var maxProfit = function(prices) {
  // 提示中给出了 prices.length >= 1
  if (prices.length === 1) return 0;
  let max = 0
  for (let slow = 0; slow < prices.length - 1; slow++) {
    for (let fast = slow + 1; fast < prices.length; fast++) {
      max = Math.max(max, prices[fast] - prices[slow])
      // 这里还有个没什么卵用的另一种写法，也过不去，只是写法不同，换成三元表达式
      let profit = prices[fast] - prices[slow]
      max = max > profit ? max : profit
    }
  }
  return max
};
```

* 因此思路得先降低时间复杂度，借鉴的是只用一次遍历就做到，先以第一项为最小值计算，在遍历时重新给最小值赋值
* 时间复杂度超过 81.97% 提交，空间复杂度超过 92.55% 提交

```js
var maxProfit = function(prices) {
  if (prices.length === 1) return 0;
  let res = 0
  let min = prices[0]
  for (let i = 1; i < prices.length; i++) {
    if (prices[i] < min) {
      min = prices[i]
    }
    if (prices[i] - min > res) {
      res = prices[i] - min
    }
  }
  return res
}
```

### 136. 只出现一次的数字

* 题目说明提出了「算法应该具有线性时间复杂度」+「不使用额外空间来实现」的额外要求，作为菜狗当然第一次做先忽略这个只追求通过就得
* 按照「遇事不决，迭代玄学」的菜狗想法，我想用两次遍历来硬解，尝试后写不出来。。。于是换一次遍历
* 第一种：遍历硬解，利用数组的 indexOf 和 lastIndexOf 方法，对比第一次出现的索引和最后一次出现的索引
  * 比如一个数组 [2, 1, 2]，`nums.indexOf(2)` 就是 0，`nums.lastIndexOf(2)` 就是 2，这样找相同的
  * 时间复杂度超过 5.5% 提交，空间复杂度超过 93.81% 提交，硬解就是时间复杂度不好看

```js
var singleNumber = function(nums) {
  for (let i = 0; i < nums.length; i++) {
    if (nums.indexOf(nums[i]) === nums.lastIndexOf(nums[i])) {
      return nums[i]
    }
  }
}
```

* 第二种：先排序再比较前后项
  * 时间复杂度超过 11.86% 提交，空间复杂度超过 5.00% 提交，因为有排序所以最少也得 O(nlog(n))，时间复杂度也就比第一种硬解好看一点点

```js
var singleNumber = function(nums) {
  nums.sort((a, b) => a - b)
  for (let i = 0; i < nums.length; i++) {
		// 这里当 i 为 0 时，nums[i - 1] 是 undefined，i 为 nums.length - 1时，nums[i + 1] 也是 undefined
    // 但是不妨碍 if 语句的执行，本来也不相等就是，逻辑上需要跟左右都比较一下，只判断一边是过不去的
    if (nums[i] !== nums[i + 1] && nums[i] !== nums[i - 1]) return nums[i]
  }
}
```

* 第三种：利用异或位运算

  * 异或运算时两个相同的数字为 0：`n ^ n = 0` ，0 和任何数异或都为那个数：`n ^ 0 = n`
  * 因此所有偶数次的都会相互抵消变为 0，再和其他数消消乐，留下结果
  * 比如一个数组是 [4, 1, 2, 1, 2] ，`4 ^ 1 ^ 2 ^ 1 ^ 2` => `1 ^ 1 ^ 2 ^ 2 ^ 4` => `0 ^ 2 ^ 2 ^ 4` => `2 ^ 2 ^ 4` => `0 ^ 4` => `4`
  * 这种时间复杂度很好看，但前提得知道有异或位运算这么回事，我觉得属于不知道就死活想不出来那种

  ```js
  // 第一种异或解法，方便看懂
  // 时间复杂度超过 98.46% 提交，空间复杂度超过 48.92% 提交
  var singleNumber = function(nums) {
    let res = 0
    for (let i of nums) res ^= i;
    return res
  }
  ```

  ```js
  // 第二种，使用数组 reduce 方法，一行就写完
  // 时间复杂度超过 95.81% 提交，空间复杂度超过 80.15% 提交
  var singleNumber = function(nums) {
    return nums.reduce((sum, cur) => sum ^ cur)
  }
  ```

* 第四种：哈希（暂时留坑）

### 169. 多数元素

* 这道题我一开始的时候就没仔细，要求输出多数元素，也就是输出一个数字，不是一个数组可能有好几个答案

* 第一种：用一个变量配合双层 for 循环

  * 第一次尝试只能通过 34 / 43 的测试用例，输入 [1] 和 [2,2,3,3,3,3,2] 就过不去了

  ```js
  var majorityElement = function(nums) {
    let count = 0 // 这里 count 初始化的位置有问题，会一直叠加
    for (let i = 0; i < nums.length; i++) {
      for (let j = i + 1; j < nums.length; j++) {
        if (nums[j] === nums[i]) {
          count++
          if (count === Math.floor(nums.length / 2)) {
            return nums[j]
          }                                              
        }
      }
    }
  }
  ```

  * 加上 base case 和改变 count 位置后就过去了，但是时间复杂度很难看，毕竟是 O(n²) 以上
  * 时间复杂度超过 6.29% 提交，空间复杂度超过 83.35% 提交

  ```js
  var majorityElement = function(nums) {
    if (nums.length === 1) return nums[0];
    for (let i = 0; i < nums.length; i++) {
      let count = 0
      for (let j = i + 1; j < nums.length; j++) {
        if (nums[j] === nums[i]) {
          count++
          if (count === Math.floor(nums.length / 2)) {
            return nums[j]
          }                                              
        }
      }
    }
  }
  ```

* 第二种：借鉴自安老师，只排序然后输出 `nums.length / 2` 位置的数字，如果出现频率大于一半，一半位置的数字就是结果
  * 这种解法我感觉有点像脑筋急转弯，转过来了就直接排个序就完事了
  * 时间复杂度超过 74.10% 提交，空间复杂度超过 18.45% 提交，时间复杂度为 O(nlogn)，空间复杂度为 O(logn)

```js
var majorityElement = function(nums) {
  nums.sort((a, b) => a - b)
  return nums[Math.floor(nums.length / 2)]
}
```

* 第三种：借鉴摩尔投票法
  * 题目的进阶要求里提到了尝试设计时间复杂度为 O(n)、空间复杂度为 O(1) 的算法，摩尔投票法就可以达成这个要求
  * 那摩尔投票法是啥呢，我看了一圈大神题解，找了一种我能理解的给记下来了
    * 维护一个候选结果 candidate 和它出现的次数 count，初始时 candidate 可以为任何值，count 为 0
    * 遍历数组，对每个元素 i，在判断之前如果 count 为 0，先将 i 的值赋给 candidate，然后开始判断
      * 如果 `i === candidate`，count 加 1
      * 如果 `i !== candidate` ，count 减 1，当减为 0 时，将下一个数赋给 candidate
    * 遍历完后 candidate 即为整个数组的众数
  * 这种解法感觉也算是脑筋急转弯，但是技巧性更强，像我这种就不可能想得出来
  * 时间复杂度超过 95.92% 提交，空间复杂度超过 52.26% 提交

```js
var majorityElement = function(nums) {
  let count = 0
  let candidate
  for (let i of nums) { // 遍历数组
    if (count === 0) candidate = i;
    if (i === candidate) {
      count++
    } else {
      count--
    }
  }
  return candidate
}
```

### 217. 存在重复元素

* 第一种：用 Set 数据结构直接比较长度
  * 这个是我第一个想到的，感觉也粗暴易懂
  * 时间复杂度超过 65.35% 提交，空间复杂度超过 57.83% 提交

```js
var containsDuplicate = function(nums) {
  let temp = [...new Set(nums)]
  if (temp.length === nums.length) return false;
  else return true;
}
```

* 第二种：用数组的原生 API 系列

  * `indexOf()` 方法：返回在数组中可以找到给定元素的**第一个**索引，如果不存在，则返回 -1
  * `indexOf(searchElement, fromIndex)` 中第一个参数是要查找的元素，第二个参数是可选的，表示开始查找的位置，如果该索引值大于或等于数组长度，意味着不会在数组里查找，返回 -1
    * 时间复杂度超过 10.87% 提交，空间复杂度超过 90.40% 提交

  ```js
  var containsDuplicate = function(nums) {
    for (let i = 0; i < nums.length; i++) {
      // 这里我感觉稍微有那么一丢丢绕，就是这个 i 不是索引嘛，nums.indexOf(nums[i]) 还是索引
      // indexOf 又是找一个数字出现的第一个索引，所以就是对比一个数字的当前索引和它第一次出现的索引相等不
    	if (nums.indexOf(nums[i]) !== i) return true;
    }
    return false
  }
  ```

  * `lastIndexOf()` 方法：返回指定元素（也即有效的 JavaScript 值或变量）在数组中的**最后一个**的索引，如果不存在则返回 -1，从数组的后面向前查找，从 `fromIndex` 处开始
    * 时间复杂度超过 5.00% 提交，空间复杂度超过 94.18% 提交

  ```js
  var containsDuplicate = function(nums) {
    for (let i = nums.length - 1; i >= 0; i--) {
      // 这个就是倒序了，比如 [1,2,3,1] 这个数组，从后往前找，找到左边的 1 时，i 为 0，最后一个索引是 3
      if (nums.lastIndexOf(nums[i]) !== i) return true;
    }
    return false
  }
  ```

  * `some()` 方法：测试数组中是不是至少有 1 个元素通过了被提供的函数测试，它返回的是一个 Boolean 类型的值
    * 时间复杂度超过 10.71% 提交，空间复杂度超过 97.69% 提交，这种我感觉还是 `indexOf()` 方法的变种，多用一个 API 达成一行的炫酷效果

  ```js
  var containsDuplicate = function(nums) {
    return nums.some((item, index, arr) => arr.indexOf(item) !== index)
  }
  ```

  * `every()` 方法：测试一个数组内的所有元素是否都能通过某个指定函数的测试，它返回是一个 Boolean 类型的值
    * 时间复杂度超过 10.71% 提交，空间复杂度超过 96.60% 提交，这个当然也同理

  ```js
  var containsDuplicate = function(nums) {
    return !nums.every((item, index, arr) => arr.indexOf(item) === index)
  }
  ```

  * `includes()` 方法：用来判断一个数组是否包含一个指定的值，如果包含则返回 `true`，否则返回 `false`
    * 时间复杂度超过 10.98% 提交，空间复杂度超过 87.56% 提交，这种肯定不如 Set 来的好看

  ```js
  var containsDuplicate = function(nums) {
    let temp = []
    for (let i = 0; i < nums.length; i++) {
      // 这个就是如果临时数组里发现重复了就返回 true，没发现就正常遍历挨个推进去
      if (temp.includes(nums[i])) return true;
      else temp.push(nums[i])
    }
    return false
  }
  ```

* 第三种：双指针法

  * 这个也是比较经典的无脑暴力解法，但是这种写时候需要注意一点细节
  * 时间复杂度超过 13.18% 提交，空间复杂度超过 96.90% 提交，这种不用说时间复杂度肯定不好看

```js
var containsDuplicate = function(nums) {
  for (let i = 0; i < nums.length - 1; i++) { // 需要注意 i 在数组倒数第二个截止
    for (let j = i + 1; j < nums.length; j++) { // j 在数组最后一个截止
      if (nums[i] === nums[j]) return true;
    }
  }
  return false
}
```

* 第四种：先排序，再找相同两位相邻数字
  * 这个感觉也是平时会想到的方法中的一种，遇事不决，排序解决
  * 时间复杂度超过 32.75% 提交，空间复杂度超过 40.70% 提交，都用排序了，时间复杂度最少 O(nlogn)

```js
var containsDuplicate = function(nums) {
  nums.sort((a, b) => a - b)
  for (let i = 0; i < nums.length - 1; i++) { // 这里 i 也要在数组倒数第二个截止
    if (nums[i] === nums[i + 1]) return true;
  }
  return false
}
```

### 219. 存在重复元素 II

* 有的问题带个 II 的感觉一般趁热打铁一块答了好一些，感觉就是第一个的稍微变种，读题时间也不用很长对吧
* 第一种：暴力解法，直接嵌套遍历
  * 时间复杂度超过 12.76% 提交，空间复杂度超过 90.62% 提交

```js
var containsNearbyDuplicate = function(nums, k) {
  for (let i = 0; i < nums.length - 1; i++) {
    for (let j = i + 1; j < nums.length; j++) {
      if (nums[i] === nums[j] && Math.abs(i - j) <= k) return true;
    }
  }
  return false
}
```

* 第二种，用 `indexOf()` 方法的第二个参数 `fromIndex`，这种我也是借鉴来的
  * 时间复杂度超过 8.03% 提交，空间复杂度超过 90.27% 提交，这种虽然只用一次遍历，但时间复杂度比 O(n²) 还高

```js
var containsNearbyDuplicate = function(nums, k) {
  // 这种只用遍历一次
  for (let i = 0; i < nums.length; i++) {
    // nums.indexOf(nums[i], i + 1) > 0 用来确定数组中存在重复元素，如果是 -1 说明不存在重复元素
    // nums.indexOf(nums[i], i + 1) 就是上面解法中的 j，理解起来麻烦一些我感觉，其实就是上一个的变种
    if (nums.indexOf(nums[i], i + 1) > 0 && Math.abs(i - nums.indexOf(nums[i], i + 1)) <= k) return true;
  }
  return false
}
```

* 第三种：滑动窗口解法，暂时留坑

### 268. 丢失的数字

* 第一种：我想的是比较暴力的先排序再遍历的解法

  * 第一次尝试只能通过 110 / 122 的测试用例，[0, 1] 这种就过不去

  ```js
  var missingNumber = function(nums) {
    nums.sort((a, b) => a - b)
    for (let i = 0; i < nums.length; i++) {
      if (nums[i] !== i) return i
    }
  }
  ```

  * 第二次补充后通过，时间复杂度超过 43.04% 提交，空间复杂度超过 41.17% 提交

  ```js
  var missingNumber = function(nums) {
    nums.sort((a, b) => a - b)
    for (let i = 0; i < nums.length; i++) {
      if (nums[i] !== i) return i;
      else if (i === nums.length - 1) return nums.length
    }
  }
  ```

* 第二种：使用异或运算解法：`n ^ n === 0` && `n ^ 0 === n，`让每个元素和索引进行异或运算

  * 因为一个数和它自身做异或为 0，和 0 做异或还是它本身，所以给 nums 数组补一位
  * 比如 nums = [0, 3, 1, 4]

  ![22100801](../assets/22100801.png)

  * 把索引补一位后，每个元素就可以和自身索引互相对应

  ![22100802](../assets/22100802.png)

  * 这样让把数组内的每一项分别和索引做异或运算，最后会留下丢失的那个数字和 0，异或的结果就是这个数字
  * 时间复杂度超过 92.47% 提交，空间复杂度超过 84.06% 提交

```js
var missingNumber = function(nums) {
  let res = 0;
  for (let i = 0; i < nums.length; i++) {
    res ^= nums[i]
  }
  // 注意遍历索引数组时需要补一位，是 index <= nums.length
  for (let j = 0; j <= nums.length; j++) {
    res ^= j
  }
  return res
}
```

* 第三种：等差数列求和解法
  * 来自拉神的脑筋急转弯式解法，题目的意思可以这样理解，现在有个等差数列 0, 1, 2,…, n，其中少了某一个数字，那这个数字就是`sum(0,1,..n) - sum(nums)`
  * 这个我感觉前提得能先想起来并且记得等差数列的公式，就是 「(首项 + 末项) * 项数 / 2」
  * 时间复杂度超过 74.97% 提交，空间复杂度超过 80.17% 提交

```js
var missingNumber = function(nums) {
  const len = nums.length
  // 等差数列公式：(首项 + 末项) * 项数 / 2
  let seqSum = ((0 + len) * (len + 1)) / 2
  // 原数组的求和可以直接用 reduce 方法得出
  let numsSum = nums.reduce((sum, cur) => sum + cur, 0)
  return seqSum - numsSum
}
```

### 349. 两个数组的交集

### 350. 两个数组的交集 II





