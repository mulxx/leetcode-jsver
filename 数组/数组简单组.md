### 1. 两数之和

* 暴力解，遍历两次数组，时间复杂度应该在 O(n²) 以上
* 时间复杂度超过 24.96% 提交，空间复杂度超过 67.71% 提交（可能是最无脑的解法，就是不太好看）

```js
var twoSum = function(nums, target) {
  let res = []
  for (let i = 0; i < nums.length; i++) {
    // 这里初始化 j 的时候需要注意不能让 j = 1，否则是过不去的，只能通过 38 / 57 的测试用例
    for (let j = i + 1; j < nums.length; j++) {
      if (nums[i] + nums[j] === target) {
        res.push(i)
        res.push(j)
      }
    }
  }
  return res
};
```

* HashTable 版进阶（待填坑）

### 26. 删除有序数组中的重复项

* 双指针解法（拉神说的**只要数组有序，就应该想到双指针技巧**），因为需要「原地」删除，所以考虑用快慢指针来解
* 我第一次做这道题的时候就没好好审题，违背了「不要使用额外的空间，必须在原地修改输入数组」，所以要细心好吧
* 这里可以参考拉神的 GIF 图，理解起来就很直观
* 时间复杂度超过 48.08% 提交，空间复杂度超过 50.40% 提交

```js
var removeDuplicates = function(nums) {
  // 提示中给出了 nums.length >= 1，这里特殊处理一下
  if (nums.length === 1) return 1;
  let slow = 0, fast = 0
  while (fast < nums.length) {
    if (nums[fast] !== nums[slow]) {
      // 这两行需要注意顺序不能反过来，否则只能通过 6 / 361 的测试用例，想的时候可以脑补一下拉神的动图是吧
      slow++
      nums[slow] = nums[fast]
    }
    fast++
  }
  // 这里 nums[0 ... slow] 是最后的去重结果,数组长度为 slow + 1
  return slow + 1
}
```

* 但有意思的一个地方我在自己写的时候把 fast 指针初始化为 1 了，其他地方完全不变，也顺利通过了，甚至时间复杂度还超过 79.21% 提交，比 48.04% 还好（黑人问号脸）？
* 这个问题我的理解应该是这样，因为一开始就将 fast 指针设为 1，可以少跑一次循环，因为当 slow = fast = 0 时，两个数字肯定是一样的，在自己打 log 测试时也佐证了我的想法

### 27. 移除元素

* 这道题跟 26 题有些像，还是原地操作数组，还可以用快慢指针，但这里题目没说是有序数组哈
* 时间复杂度超过 71.80% 提交，空间复杂度超过 51.39% 提交

```js
var removeElement = function(nums, val) {
  // 提示中给出了 nums.length >= 0
  if (nums.length === 0) return 0;
  let slow = 0, fast = 0
  while (fast < nums.length) {
    if (nums[fast] !== val) {
      // 这两行注意顺序跟 26 题反过来了，稍微脑筋急转弯一下如果是连着做这两道题是吧
      nums[slow] = nums[fast]
      slow++
    }
    fast++
  }
  // 这里 nums[0 ... slow - 1] 是最后移除完 target 的结果，因此数组长度是 slow - 1 + 1 = slow
  // return slow 还是 slow + 1 这里我感觉有点绕，想了半天。。。
  return slow
}
```

* 这道题把 fast 初始化为 1 就不行了，因为直接跳过判断第一个元素了那肯定不对啊

### 35. 搜索插入位置

* 题目要求说必须使用时间复杂度为 `O(log n)` 的算法，按理说应该直接想到二分法，但是我看提示中 nums 为 **无重复元素** 的 **升序** 排列数组，一看「数组」「有序」，我的第一次尝试居然就用了快慢指针。。。
* 时间复杂度超过 85.41% 提交，空间复杂度超过 48.33% 提交

```js
var searchInsert = function(nums, target) {
  let slow = 0, fast = 0
  while (fast < nums.length) {
    if (nums[fast] === target) {
      return fast
    } else if (nums[fast] > target) {
      return slow
    } else if (nums[fast] < target) {
      slow = fast + 1
    }
    fast++
  }
  return slow
}
```

* 二分法这题参考 angela 大神，应该可以分为左闭右闭，左闭右开和左闭右开简化版，左闭右开就暂时留坑。。。
* 我的无脑版左闭右闭解法（框架直接套拉神的二分框架）
* 时间复杂度超过 42.82% 提交，空间复杂度超过 60.46% 提交

```js
var searchInsert = function(nums, target) {
  let left = 0, right = nums.length - 1
  while (left <= right) {
    // 这里这样写是有说法的，你看无脑取 mid 就直接 Math.floor((left + right) / 2) 对吧
    // 但是不管是 JS 语言或其他语言在计算 mid 时都需要防止溢出，所以就优化为 Math.floor(left + (right - left) / 2)，避免 left 和 right 太大直接相加溢出，撅撅了
    // 再因为 JS 中 >> 移位运算比除法操作性能好很多，所以就最终优化为 left + ((right - left) >> 1)，这种还不用套一层 Math.floor 处理
    let mid = left + ((right - left) >> 1)
    if (nums[mid] === target) {
      return mid
    } else if (nums[mid] < target) {
      left = mid + 1 // 这里 < 和 > 下面改变边界要仔细想一下不要混淆，我第一次就糊涂了
    } else if (nums[mid] > target) {
      right = mid - 1
    }
  }
  return left
}
```

### 121. 买卖股票的最佳时机

* 如果翻译一下这个股票啥的其实就是求数组中最大值和最小值的差，我的第一个想法就是遍历两次配合快慢指针，没错我又只能想到快慢指针。。。
* 但这种做法会超出时间限制，只能通过 206 / 211 的测试用例，所以时间复杂度 O(n²) 以上，也通过不了

```js
var maxProfit = function(prices) {
  // 提示中给出了 prices.length >= 1
  if (prices.length === 1) return 0;
  let max = 0
  for (let slow = 0; slow < prices.length - 1; slow++) {
    for (let fast = slow + 1; fast < prices.length; fast++) {
      max = Math.max(max, prices[fast] - prices[slow])
      // 这里还有个没什么卵用的另一种写法，也过不去，只是写法不同，换成三元表达式
      let profit = prices[fast] - prices[slow]
      max = max > profit ? max : profit
    }
  }
  return max
};
```

* 因此思路得先降低时间复杂度，借鉴的是只用一次遍历就做到，先以第一项为最小值计算，在遍历时重新给最小值赋值
* 时间复杂度超过 81.97% 提交，空间复杂度超过 92.55% 提交

```js
var maxProfit = function(prices) {
  if (prices.length === 1) return 0;
  let res = 0
  let min = prices[0]
  for (let i = 1; i < prices.length; i++) {
    if (prices[i] < min) {
      min = prices[i]
    }
    if (prices[i] - min > res) {
      res = prices[i] - min
    }
  }
  return res
}
```

### 136. 只出现一次的数字

* 题目说明提出了「算法应该具有线性时间复杂度」+「不使用额外空间来实现」的额外要求，作为菜狗当然第一次做先忽略这个只追求通过就得
* 按照「遇事不决，迭代玄学」的菜狗想法，我想用两次遍历来硬解，尝试后写不出来。。。于是换一次遍历
* 第一种：遍历硬解，利用数组的 indexOf 和 lastIndexOf 方法，对比第一次出现的索引和最后一次出现的索引
  * 比如一个数组 [2, 1, 2]，`nums.indexOf(2)` 就是 0，`nums.lastIndexOf(2)` 就是 2，这样找相同的
  * 时间复杂度超过 5.5% 提交，空间复杂度超过 93.81% 提交，硬解就是时间复杂度不好看

```js
var singleNumber = function(nums) {
  for (let i = 0; i < nums.length; i++) {
    if (nums.indexOf(nums[i]) === nums.lastIndexOf(nums[i])) {
      return nums[i]
    }
  }
}
```

* 第二种：先排序再比较前后项
  * 时间复杂度超过 11.86% 提交，空间复杂度超过 5.00% 提交，因为有排序所以最少也得 O(nlog(n))，时间复杂度也就比第一种硬解好看一点点

```js
var singleNumber = function(nums) {
  nums.sort((a, b) => a - b)
  for (let i = 0; i < nums.length; i++) {
		// 这里当 i 为 0 时，nums[i - 1] 是 undefined，i 为 nums.length - 1时，nums[i + 1] 也是 undefined
    // 但是不妨碍 if 语句的执行，本来也不相等就是，逻辑上需要跟左右都比较一下，只判断一边是过不去的
    if (nums[i] !== nums[i + 1] && nums[i] !== nums[i - 1]) return nums[i]
  }
}
```

* 第三种：利用异或位运算

  * 异或运算时两个相同的数字为 0：`n ^ n = 0` ，0 和任何数异或都为那个数：`n ^ 0 = n`
  * 因此所有偶数次的都会相互抵消变为 0，再和其他数消消乐，留下结果
  * 比如一个数组是 [4, 1, 2, 1, 2] ，`4 ^ 1 ^ 2 ^ 1 ^ 2` => `1 ^ 1 ^ 2 ^ 2 ^ 4` => `0 ^ 2 ^ 2 ^ 4` => `2 ^ 2 ^ 4` => `0 ^ 4` => `4`
  * 这种时间复杂度很好看，但前提得知道有异或位运算这么回事，我觉得属于不知道就死活想不出来那种

  ```js
  // 第一种异或解法，方便看懂
  // 时间复杂度超过 98.46% 提交，空间复杂度超过 48.92% 提交
  var singleNumber = function(nums) {
    let res = 0
    for (let i of nums) res ^= i;
    return res
  }
  ```

  ```js
  // 第二种，使用数组 reduce 方法，一行就写完
  // 时间复杂度超过 95.81% 提交，空间复杂度超过 80.15% 提交
  var singleNumber = function(nums) {
    return nums.reduce((sum, cur) => sum ^ cur)
  }
  ```

* 第四种：哈希（暂时留坑）

### 169. 多数元素

* 这道题我一开始的时候就没仔细，要求输出多数元素，也就是输出一个数字，不是一个数组可能有好几个答案

* 第一种：用一个变量配合双层 for 循环

  * 第一次尝试只能通过 34 / 43 的测试用例，输入 [1] 和 [2,2,3,3,3,3,2] 就过不去了

  ```js
  var majorityElement = function(nums) {
    let count = 0 // 这里 count 初始化的位置有问题，会一直叠加
    for (let i = 0; i < nums.length; i++) {
      for (let j = i + 1; j < nums.length; j++) {
        if (nums[j] === nums[i]) {
          count++
          if (count === Math.floor(nums.length / 2)) {
            return nums[j]
          }                                              
        }
      }
    }
  }
  ```

  * 加上 base case 和改变 count 位置后就过去了，但是时间复杂度很难看，毕竟是 O(n²) 以上
  * 时间复杂度超过 6.29% 提交，空间复杂度超过 83.35% 提交

  ```js
  var majorityElement = function(nums) {
    if (nums.length === 1) return nums[0];
    for (let i = 0; i < nums.length; i++) {
      let count = 0
      for (let j = i + 1; j < nums.length; j++) {
        if (nums[j] === nums[i]) {
          count++
          if (count === Math.floor(nums.length / 2)) {
            return nums[j]
          }                                              
        }
      }
    }
  }
  ```

* 第二种：借鉴自安老师，只排序然后输出 `nums.length / 2` 位置的数字，如果出现频率大于一半，一半位置的数字就是结果
  * 这种解法我感觉有点像脑筋急转弯，转过来了就直接排个序就完事了
  * 时间复杂度超过 74.10% 提交，空间复杂度超过 18.45% 提交，时间复杂度为 O(nlogn)，空间复杂度为 O(logn)

```js
var majorityElement = function(nums) {
  nums.sort((a, b) => a - b)
  return nums[Math.floor(nums.length / 2)]
}
```

* 第三种：借鉴摩尔投票法
  * 题目的进阶要求里提到了尝试设计时间复杂度为 O(n)、空间复杂度为 O(1) 的算法，摩尔投票法就可以达成这个要求
  * 那摩尔投票法是啥呢，我看了一圈大神题解，找了一种我能理解的给记下来了
    * 维护一个候选结果 candidate 和它出现的次数 count，初始时 candidate 可以为任何值，count 为 0
    * 遍历数组，对每个元素 i，在判断之前如果 count 为 0，先将 i 的值赋给 candidate，然后开始判断
      * 如果 `i === candidate`，count 加 1
      * 如果 `i !== candidate` ，count 减 1，当减为 0 时，将下一个数赋给 candidate
    * 遍历完后 candidate 即为整个数组的众数
  * 这种解法都不是脑筋急转弯了，属于会者不难难者不会了，不知道估计不太能想的出来。。。。
  * 时间复杂度超过 95.92% 提交，空间复杂度超过 52.26% 提交

```js
var majorityElement = function(nums) {
  let count = 0
  let candidate
  for (let i of nums) { // 遍历数组
    if (count === 0) candidate = i;
    if (i === candidate) {
      count++
    } else {
      count--
    }
  }
  return candidate
}
```

