### 1. 两数之和

* 暴力解，遍历两次数组，时间复杂度应该在 O(n²) 以上
* 时间复杂度超过 24.96% 提交，空间复杂度超过 67.71% 提交（可能是最无脑的解法，就是不太好看）

```js
var twoSum = function(nums, target) {
  let res = []
  for (let i = 0; i < nums.length; i++) {
    // 这里初始化 j 的时候需要注意不能让 j = 1，否则是过不去的，只能通过 38 / 57 的测试用例
    for (let j = i + 1; j < nums.length; j++) {
      if (nums[i] + nums[j] === target) {
        res.push(i)
        res.push(j)
      }
    }
  }
  return res
};
```

* HashTable 版进阶（待填坑）

### 26. 删除有序数组中的重复项

* 双指针解法（拉神说的**只要数组有序，就应该想到双指针技巧**），因为需要「原地」删除，所以考虑用快慢指针来解
* 我第一次做这道题的时候就没好好审题，违背了「不要使用额外的空间，必须在原地修改输入数组」，所以要细心好吧
* 这里可以参考拉神的 GIF 图，理解起来就很直观
* 时间复杂度超过 48.08% 提交，空间复杂度超过 50.40% 提交

```js
var removeDuplicates = function(nums) {
  // 提示中给出了 nums.length >= 1，这里特殊处理一下
  if (nums.length === 1) return 1;
  let slow = 0, fast = 0
  while (fast < nums.length) {
    if (nums[fast] !== nums[slow]) {
      // 这两行需要注意顺序不能反过来，否则只能通过 6 / 361 的测试用例，想的时候可以脑补一下拉神的动图是吧
      slow++
      nums[slow] = nums[fast]
    }
    fast++
  }
  // 这里 nums[0 ... slow] 是最后的去重结果,数组长度为 slow + 1
  return slow + 1
}
```

* 但有意思的一个地方我在自己写的时候把 fast 指针初始化为 1 了，其他地方完全不变，也顺利通过了，甚至时间复杂度还超过 79.21% 提交，比 48.04% 还好（黑人问号脸）？
* 这个问题我的理解应该是这样，因为一开始就将 fast 指针设为 1，可以少跑一次循环，因为当 slow = fast = 0 时，两个数字肯定是一样的，在自己打 log 测试时也佐证了我的想法

### 27. 移除元素

* 这道题跟 26 题有些像，还是原地操作数组，还可以用快慢指针，但这里题目没说是有序数组哈
* 时间复杂度超过 71.80% 提交，空间复杂度超过 51.39% 提交

```js
var removeElement = function(nums, val) {
  // 提示中给出了 nums.length >= 0
  if (nums.length === 0) return 0;
  let slow = 0, fast = 0
  while (fast < nums.length) {
    if (nums[fast] !== val) {
      // 这两行注意顺序跟 26 题反过来了，稍微脑筋急转弯一下如果是连着做这两道题是吧
      nums[slow] = nums[fast]
      slow++
    }
    fast++
  }
  // 这里 nums[0 ... slow - 1] 是最后移除完 target 的结果，因此数组长度是 slow - 1 + 1 = slow
  // return slow 还是 slow + 1 这里我感觉有点绕，想了半天。。。
  return slow
}
```

* 这道题把 fast 初始化为 1 就不行了，因为直接跳过判断第一个元素了那肯定不对啊

### 35. 搜索插入位置

* 题目要求说必须使用时间复杂度为 `O(log n)` 的算法，按理说应该直接想到二分法，但是我看提示中 nums 为 **无重复元素** 的 **升序** 排列数组，一看「数组」「有序」，我的第一次尝试居然就用了快慢指针。。。
* 时间复杂度超过 85.41% 提交，空间复杂度超过 48.33% 提交

```js
var searchInsert = function(nums, target) {
  let slow = 0, fast = 0
  while (fast < nums.length) {
    if (nums[fast] === target) {
      return fast
    } else if (nums[fast] > target) {
      return slow
    } else if (nums[fast] < target) {
      slow = fast + 1
    }
    fast++
  }
  return slow
}
```

* 二分法这题参考 angela 大神，应该可以分为左闭右闭，左闭右开和左闭右开简化版，左闭右开就暂时留坑。。。
* 我的无脑版左闭右闭解法（框架直接套拉神的二分框架）
* 时间复杂度超过 42.82% 提交，空间复杂度超过 60.46% 提交

```js
var searchInsert = function(nums, target) {
  let left = 0, right = nums.length - 1
  while (left <= right) {
    // 这里这样写是有说法的，你看无脑取 mid 就直接 Math.floor((left + right) / 2) 对吧
    // 但是不管是 JS 语言或其他语言在计算 mid 时都需要防止溢出，所以就优化为 Math.floor(left + (right - left) / 2)，避免 left 和 right 太大直接相加溢出，撅撅了
    // 再因为 JS 中 >> 移位运算比除法操作性能好很多，所以就最终优化为 left + ((right - left) >> 1)，这种还不用套一层 Math.floor 处理
    let mid = left + ((right - left) >> 1)
    if (nums[mid] === target) {
      return mid
    } else if (nums[mid] < target) {
      left = mid + 1 // 这里 < 和 > 下面改变边界要仔细想一下不要混淆，我第一次就糊涂了
    } else if (nums[mid] > target) {
      right = mid - 1
    }
  }
  return left
}
```

