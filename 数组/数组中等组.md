## 11. 盛最多水的容器

根据[拉神讲解](https://labuladong.gitee.io/algo/4/33/128/)，这道题跟数组困难组 #42 接雨水一题有相似的思路，因此个人感觉刷完这道后可以再去看下那道题

第一种：双指针解法

双指针的思路跟拉神总结的另一篇[专门讲双指针技巧](https://labuladong.gitee.io/algo/1/5/)的文章提到的一样，因为我的顺序是先刷了那篇文章中的题，所以这里就不再赘述

时间复杂度超过 94.86% 提交，空间复杂度超过 58.11% 提交，时间复杂度为 O(n)

```js
var maxArea = function(height) {
  let left = 0, right = height.length - 1
  let max = 0
  while (left < right) {
    // temp 即容器可以储存的最大水量，也就是左右指针构成的矩形的面积，取最小值是因为面积由较小的一边决定
    let temp = Math.min(height[left], height[right]) * (right - left)
    max = Math.max(max, temp)
    // 如果一边高度更低，则将这一边向中间移动，因为这条边可能会变高，「有可能」使矩形面积变大
    // 相反，如果移动更高的一边，矩形的面积不可能变得更大，因为矩形面积由另一边的更短高度决定
    if (height[left] > height[right]) {
      right--
    } else {
      left++
    }
  }
  return max
};
```

## 33. 搜索旋转排序数组

如果仔细读题了会看到题目要求的「必须设计时间复杂度为 O(log n) 的算法」，那不用动脑都能想到的那些方法肯定不用我多说都知道就算能提交通过，首先这道题是中等难度对吧，其次面试官也不傻，到时候还得再写一遍也没意思是吧

第一种：二分搜索

一般看到要求 O(log n) 的时间复杂度就差不多跟二分划等号了，这不是我说的哈，是从别的地方看来的，具体是哪我也忘了。。。

这道题的思路我也没想出来，只知道用二分搜索，但就是不知道咋写，直接去看官方题解了，讲的也还好，但评论第一条大家都觉得说得好，我引用一下在这，说的是把数组分为左右两半后，一定有一半是有序的，另一半可能是有序的，也可能是部分有序的

此时有序的一半就正常用二分法查找，无序的一半也再分为两半，一定有一半是有序的，另一半可能是有序的，也可能是部分有序的，就这样循环

还有一条评论说的是比二分法多了一个判断哪半边有序的步骤，因为只有在有序的那半边才能用二分法判断 target 在不在

时间复杂度超过 51.70% 提交，空间复杂度超过 76.15% 提交，时间复杂度为 O(log n)， 空间复杂度为 O(1)

```js
var search = function(nums, target) {
  const len = nums.length
  if (len === 0) return -1; // base case
  if (len === 1) return nums[0] === target ? 0 : -1; // base case
  let left = 0, right = nums.length - 1
  let mid = left + ((right - left) >> 1)
  while (left <= right) {
    let mid = left + ((right - left) >> 1)
    if (nums[mid] === target) {
      return mid;
    } else if (nums[mid] < nums[right]) { // 右半部分是有序的
      // 且满足 target 的值在 [mid + 1, right] 区间，即 target 是否在有序的这半边
      if (nums[mid] < target && target <= nums[right]) {
        left = mid + 1 // 将搜索范围缩至 [mid + 1, right]
      } else {
        right = mid - 1 // 否则去 [l, mid - 1] 中寻找
      }
    } else { // 左半部分是有序的
      // 且满足 target 的值在[left, mid - 1] 区间
      if (nums[0] <= target && target < nums[mid]) {
        right = mid - 1 // 将搜索范围缩至 [left, mid - 1]
      } else {
        left = mid + 1 // 否则去 [mid + 1, right] 中寻找
      }
    }
  }
  return -1
};
```

## 34. 在排序数组中查找元素的第一个和最后一个位置

第一种：二分搜索

这道题可以用[拉神的二分搜索框架](https://labuladong.gitee.io/algo/2/20/29/)的进阶版，用到寻找左侧边界和右侧边界的解法，属于基本二分搜索的进阶版，如果第一次刷到这个也可以考虑循序渐进先刷一下 #704 最基础的二分查找，这道题感觉细节也很多

此解法的具体细节与拉神有些许不同的地方参考了[安神的解法](https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/solution/ba-er-fen-fa-de-xi-jie-dian-shuo-tou-by-w9bcc/)，感觉在边界处理上相对更易懂一些

时间复杂度超过 27.25% 提交，空间复杂度超过 55.30% 提交

```js
var searchRange = function(nums, target) {
  const binarySearch = (isLeft) => {
    let left = 0, right = nums.length - 1

    while (left <= right) {
      let mid = left + ((right - left) >> 1)
      if (nums[mid] < target) {
        left = mid + 1
      } else if (nums[mid] > target) {
        right = mid - 1
      } else if (nums[mid] === target) {
        // 搜索两侧边界关键在于对这种情况处理，找到 target 时不要立即返回，不断向两侧收缩
        if (isLeft) { // 寻找左边界
          // 如果 mid 不是第一个元素并且左侧一个相邻的元素也跟 mid 相等
          if (nums[mid] === nums[mid - 1]) {
            right = mid - 1 // 收缩右侧边界，搜索区间变为 [left, mid - 1]
          } else {
            return mid;
          }
        } else { // 寻找右边界
          // 如果 mid 不是第一个元素并且右侧一个相邻的元素也跟 mid 相等
          if (nums[mid] === nums[mid + 1]) {
            left = mid + 1 // 收缩左侧边界，搜索区间变为 [mid + 1, right]
          } else {
            return mid;
          }
        }
      }
    }
    return -1
  }
  let left_bound = binarySearch(true)
  let right_bound = binarySearch(false)
  return [left_bound, right_bound]
};
```

## 167. 两数之和 II - 输入有序数组

这道题题目好长，读题都有心理障碍。。。22年11月时这道题描述比拉神题解中的描述打了几个补丁还。。。

另外这道题原来是跟整个题库第一题 #1 两数之和是一个系列的。。。。

这道题的解法比较像二分查找，因为数组是「非递减顺序」排列的，通过调节 `left` 和 `right` 就可以调整两数之和的大小

时间复杂度超过 75.11% 提交，空间复杂度超过 60.88% 提交

```js
var twoSum = function(nums, target) {
  let left = 0, right = nums.length - 1 // 一左一右两个指针相向而行
  while (left < right) {
    let sum = nums[left] + nums[right]
    if (sum === target) {
      return [left + 1, right + 1] // 题目要求索引从 1 开始
    } else if (sum < target) {
      left++ // 让 sum 大一点
    } else if (sum > target) {
      right-- // 让 sum 小一点
    }
  }
}
```

## 240. 搜索二维矩阵 II

这道题虽然没硬性要求时间复杂度，但最开始写了「高效的算法」，像这种无脑的肯定会超出时间限制的啦

```js
var searchMatrix = function(matrix, target) {
  for (let i of matrix) {
    if (i.includes(target)) return true;
  }
  return false;
};

var searchMatrix = function(matrix, target) {
  for (let i of matrix) {
    for (let j of i) {
      if (j === target) return true;
    }
  }
  return false;
};
```

我看这示例 1 的图就干想一个思路虽然我很可能实现不了啊，就是上来先比较矩阵最中间 m / 2 和 n / 2 的那个数，在示例 1 的图里就是 9，如果比 9 小，那目标值肯定就在以 9 为右下角的矩阵里，这样以左上到右下为线，依次找 1 - 5 - 9 - 17 - 30，感觉这种是不是比上面笨方法好些，但是我就这么干想，也不确定对不对，也还不知道怎么写出来

第一种解法：二分法

这种解法好多题解都提到，我觉得这位[宫神的讲解](https://leetcode.cn/problems/search-a-2d-matrix-ii/solution/gong-shui-san-xie-yi-ti-shuang-jie-er-fe-y1ns/)最清晰，虽然是 Java 写的，但肯定能看懂，核心就一句话，遍历行 / 列，然后再对列 / 行进行二分，因为每行和每列都是升序排列的，官方题解中第一条评论提到二分查找每次搜索可以排除半行或半列的元素

时间复杂度超过 34.80% 提交，空间复杂度超过 52.49% 提交，时间复杂度为 O(m logn)，对一行使用二分查找的时间复杂度为 O(log n)，最多需要进行 m 次二分查找，空间复杂度为 O(1)

```js
// 先遍历行，再对列二分
var searchMatrix = function(matrix, target) {
  let m = matrix.length, n = matrix[0].length
  for (let i = 0; i < m; i++) {
    let left = 0, right = n - 1
    while (left <= right) {
      let mid = left + ((right - left) >> 1)
      if (matrix[i][mid] === target) {
        return true
      } else if (matrix[i][mid] < target) {
        left = mid + 1
      } else if (matrix[i][mid] > target) {
        right = mid - 1
      }
    }
  }
  return false
};
```

时间复杂度超过 40.45% 提交，空间复杂度超过 30.26% 提交，时间复杂度为 O(n logm)，对一行使用二分查找的时间复杂度为 O(log m)，最多需要进行 n 次二分查找，空间复杂度为 O(1)

```js
// 先遍历列，再对行二分
var searchMatrix = function(matrix, target) {
  let m = matrix.length, n = matrix[0].length
  for (let i = 0; i < n; i++) {
    let left = 0, right = m - 1
    while (left <= right) {
      let mid = left + ((right - left) >> 1)
      if (matrix[mid][i] === target) {
        return true;
      } else if (matrix[mid][i] < target) {
        left = mid + 1
      } else if (matrix[mid][i] > target) {
        right = mid - 1
      }
    }
  }
  return false
}
```

第二种解法：Z 字形查找

官方题解叫这个名字，但实际跟拉神提供的思路是一个意思，提醒一下拉神的思路是在插件中的哈

这道题说 `matrix` 从上到下递增，从左到右递增，显然左上角是最小元素，右下角是最大元素，**如果想高效在 `matrix` 中搜索一个元素，肯定需要从某个角开始**，比如说从左上角开始，然后每次只能向右或向下移动，不要走回头路

如果真从左上角开始的话，就会发现无论向右还是向下走，元素大小都会增加，那么到底向右还是向下？不确定，那只好用类似 [拉神讲动态规划算法](https://labuladong.github.io/article/fname.html?fname=动态规划详解进阶) 的思路穷举了

但实际上不用这么麻烦，不要从左上角开始，而是从右上角开始，规定只能向左或向下移动

注意，如果向左移动，元素在减小，如果向下移动，元素在增大，这样的话就可以根据当前位置的元素和 `target` 的相对大小来判断应该往哪移动，不断接近从而找到 `target` 的位置，这样每次搜索可以排除一行或一列的元素

当然，如果想从左下角开始，规定只能向右或向上移动也可以

时间复杂度超过 88.77% 提交，空间复杂度超过 31.23% 提交，时间复杂度为 O(m + n)，由于 `(i, j)` 的初始值分别为 `(0, n - 1)`，因此 `j` 最多能被减少 n 次，`i` 最多能被增加 m 次，总搜索次数为 m + n，在这之后 `i` 和 `j` 就会超出矩阵边界，空间复杂度为 O(1)

```js
var searchMatrix = function(matrix, target) {
  let m = matrix.length, n = matrix[0].length
	let i = 0, j = n - 1 // 初始化在右上角
  while (i < m && j >= 0) {
    if (matrix[i][j] === target) return true;
    if (matrix[i][j] < target) i++; // 当前值小了，需要变大，往下移动
    else j--; // 当前值大了，需要变小，往左移动
  }
  return false; // while 循环中没有找到，则 target 不存在
}
```

## 347. 前 K 个高频元素

第一种解法：暴力解

这是第一个想到的笨方法，都不涉及到堆或者快速排序等技巧，就用一个 Map 结构加上几个数组的 API 实现，个人感觉作为中等难度的入门级差不多，因为感觉还挺需要熟练掌握数组多个 API 的

时间复杂度超过 27.09% 提交，空间复杂度超过 76.22% 提交

```js
var topKFrequent = function(nums, k) {
  const map = new Map() // 首先创建一个 Map 结构存放数组每个元素和出现的次数
  for (let i of nums) { // 遍历数组
    if (map.has(i)) {
      map.set(i, map.get(i) + 1) // 如果 Map 中的键已经存在正遍历的元素，取出对应的值将出现次数加一
    } else {
      map.set(i, 1) // 如果不存在，设其对应的值为初始值 1
    }
  }
  const arr = Array.from(map) // 将 map 结构转为数组
  arr.sort((a, b) => b[1] - a[1]) // 注意是从大到小的以值的数值大小进行排序
  return arr.slice(0, k).map(i => i[0]) // 先截取数组，然后再返回每项中的 key 值
};
```

第二种解法：快速排序（待填坑）

第三种解法：最小堆（待填坑）
