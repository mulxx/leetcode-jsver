## 11. 盛最多水的容器

根据[拉神讲解](https://labuladong.gitee.io/algo/4/33/128/)，这道题跟数组困难组 #42 接雨水一题有相似的思路，因此个人感觉刷完这道后可以再去看下那道题

第一种：双指针解法

双指针的思路跟拉神总结的另一篇[专门讲双指针技巧](https://labuladong.gitee.io/algo/1/5/)的文章提到的一样，因为我的顺序是先刷了那篇文章中的题，所以这里就不再赘述

时间复杂度超过 94.86% 提交，空间复杂度超过 58.11% 提交，时间复杂度为 O(n)

```js
var maxArea = function(height) {
  let left = 0, right = height.length - 1
  let max = 0
  while (left < right) {
    // temp 即容器可以储存的最大水量，也就是左右指针构成的矩形的面积，取最小值是因为面积由较小的一边决定
    let temp = Math.min(height[left], height[right]) * (right - left)
    max = Math.max(max, temp)
    // 如果一边高度更低，则将这一边向中间移动，因为这条边可能会变高，「有可能」使矩形面积变大
    // 相反，如果移动更高的一边，矩形的面积不可能变得更大，因为矩形面积由另一边的更短高度决定
    if (height[left] > height[right]) {
      right--
    } else {
      left++
    }
  }
  return max
};
```

## 34. 在排序数组中查找元素的第一个和最后一个位置

第一种：二分搜索

这道题可以用[拉神的二分搜索框架](https://labuladong.gitee.io/algo/2/20/29/)的进阶版，用到寻找左侧边界和右侧边界的解法，属于基本二分搜索的进阶版，如果第一次刷到这个也可以考虑循序渐进先刷一下 #704 最基础的二分查找，这道题感觉细节也很多

此解法的具体细节与拉神有些许不同的地方参考了[安神的解法](https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/solution/ba-er-fen-fa-de-xi-jie-dian-shuo-tou-by-w9bcc/)，感觉在边界处理上相对更易懂一些

时间复杂度超过 27.25% 提交，空间复杂度超过 55.30% 提交

```js
var searchRange = function(nums, target) {
  const binarySearch = (isLeft) => {
    let left = 0, right = nums.length - 1

    while (left <= right) {
      let mid = left + ((right - left) >> 1)
      if (nums[mid] < target) {
        left = mid + 1
      } else if (nums[mid] > target) {
        right = mid - 1
      } else if (nums[mid] === target) {
        // 搜索两侧边界关键在于对这种情况处理，找到 target 时不要立即返回，不断向两侧收缩
        if (isLeft) { // 寻找左边界
          // 如果 mid 不是第一个元素并且左侧一个相邻的元素也跟 mid 相等
          if (nums[mid] === nums[mid - 1]) {
            right = mid - 1 // 收缩右侧边界，搜索区间变为 [left, mid - 1]
          } else {
            return mid;
          }
        } else { // 寻找右边界
          // 如果 mid 不是第一个元素并且右侧一个相邻的元素也跟 mid 相等
          if (nums[mid] === nums[mid + 1]) {
            left = mid + 1 // 收缩左侧边界，搜索区间变为 [mid + 1, right]
          } else {
            return mid;
          }
        }
      }
    }
    return -1
  }
  let left_bound = binarySearch(true)
  let right_bound = binarySearch(false)
  return [left_bound, right_bound]
};
```

## 347. 前 K 个高频元素

第一种解法：暴力解

这是第一个想到的笨方法，都不涉及到堆或者快速排序等技巧，就用一个 Map 结构加上几个数组的 API 实现，个人感觉作为中等难度的入门级差不多，因为感觉还挺需要熟练掌握数组多个 API 的

时间复杂度超过 27.09% 提交，空间复杂度超过 76.22% 提交

```js
var topKFrequent = function(nums, k) {
  const map = new Map() // 首先创建一个 Map 结构存放数组每个元素和出现的次数
  for (let i of nums) { // 遍历数组
    if (map.has(i)) {
      map.set(i, map.get(i) + 1) // 如果 Map 中的键已经存在正遍历的元素，取出对应的值将出现次数加一
    } else {
      map.set(i, 1) // 如果不存在，设其对应的值为初始值 1
    }
  }
  const arr = Array.from(map) // 将 map 结构转为数组
  arr.sort((a, b) => b[1] - a[1]) // 注意是从大到小的以值的数值大小进行排序
  return arr.slice(0, k).map(i => i[0]) // 先截取数组，然后再返回每项中的 key 值
};
```

第二种解法：快速排序（待填坑）

第三种解法：最小堆（待填坑）
